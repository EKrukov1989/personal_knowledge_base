___
>[!warning]
>Данная статья содержит описание только тех возможностей команды, которые показались автору интересными на момент написания статьи.

Команда `find` позволяет найти в директории файлы, которые удовлетворяют заданным условиям.
___
### 1. Синтаксис: 

`find [options] [starting-point...] [expression]`

- `starting-point` - директория, в которой будет осуществляться поиск, таких может быть несколько
- `expression` - описывает условия и действия над файлами, которые подходят под эти условия

___
### 2. Expression

Expression представляет собой последовательность элементов из следующего списка:

элемент | описание
-|-
test|Элементы `test` проверяет свойства рассматриваемого файла и возвращает `true` или `false` в зависимости от результатов проверки.
action|Элемент `action` выполняет некоторое действие над файлом которое имеет side-эффекты,  а также возвращают  `true` или `false`, но в зависимости от успешности этого действия.
global option|Элемент `global option` оказывает воздействие на тесты и действия в любой части команды, всегда возвращает `true`.
positional option|Элемент `positional option` оказывает воздействие только на тесты и действия, которые следуют за ним.
operator|Элемент `operator` соединяет другие элементы между собой (например и/или)

Команда `find` выполянет все элементы в выражении слева направо, то тех пор пока результат выражения не будет определен.

>[!note]
>Если `expression` не указан, то по умолчанию используется `-print`.

___
### 3. Global options

Глобальная опция воздействует на тесты и действия по всей команде, что довольно неудобно. Поэтому имеет смысл всегда писать глобальные опции в самом начале команды, до каких-либо тестов и действий (в противном случае команда даже выкинет warning).

Глобальные опции располагаются после `<starting point>...`, а потому никак не пересекаются с обычными опциями.

`-d`
`-depth`
- обработать содержимое содержимое директории до самой директории

___
### 4. Positional options

Элемент `positional option` оказывает воздействие только на тесты и действия, которые следуют за ним. Всегда возвращает `true`.

`-regextype type`
- можно указать предпочитаемый тип регулярных выражений
- если ввести команду `find . -regextype help`, то будет выведен список доступных типов регулярных выражений. Предпочительно использовать `egrep`
___
### 5. Tests

Элемент `test` проверяет свойства файла. Далее изложены наиболее интересные тесты/

> [!note]
> Некоторые опции содержат числовой аргумент `n`. Числовой аргумент может иметь три формы:
> - `+n` -> более чем n
> - `-n` -> менее чем n
> - `n` -> ровно n

`-name <globbing_pattern>`
`-iname <globbing_pattern>` (case-insencitive version)
- проверить basename файла на соответствие паттерну
- в отличие от обычного глоббинга, wildcard-символы `*`, `?` и `[]` подходят к `.` в начале имени

`-path <globbing_pattern>`
`-ipath <globbing_pattern>` (case-insencitive version)
- проверить путь на соответствие паттерну
- в отличие от обычного глоббинга, wildcard-символы работают с символами `'.'` и `'/'`, так же как с обычными символами

>[!note]
>Тест `-path` проверяет на соответствие паттерну путь, полученный конкатенацией относительного пути и starting_point. Поэтому результат может быть разный для относительного и абсолютного starting_point.

`-regex <regular_expression>`
`-iregex <regular_expression>` (case-insencitive version)
- проверить basename файла на соответствие регулярному выражению
- регулярное выражение должно соответствовать всему пути целиком

`-mmin n`
- файл был изменен n (-n, +n) минут назад
`-mtime n`
- файл был изменен n (-n, +n) суток назад

`-size n[cwbkMG]`
- файл имеет размер n (-n, +n) указанных единиц
- возможные единицы `c=byte, w=2byte, b=512byte(default), k=Kbyte, M=Mbyte, G=Gbyte`

>[!note]
>Размер округляется до указанной единицы измерения. Например: 
>`-size -2k` подойдет файлам размером `0k` и `1k`, но не подойдет для `1500с`

`-empty`
- файл пустой (обычный файл или директория)

`-type <type>`
- файл типа `<type>`
- возможные типы: `d` - directory, `f` - regulare file, `l` - symbolic link и т.д.

`-readable`
- файл доступен для чтения текущему юзеру
`-writable`
- файл доступен для записи текущему юзеру
`-executable`
- файл доступен для исполнения текущему юзеру

`-links n`
- файл имеет n (-n, +n) жестких ссылок

___
### 6. Actions

Элемент `action` выполняет некоторое действие и так же возвращает `true` или `false`.

`-print`
- выводит полное имя файла в стандартный вывод
- имя файла завершается `\n`
- имя файла будет абсолютным или относительным, в зависимости от `starting-point`
`-print0`
- имя файла завершается `\0`
`-fprint file`
- выводит в файл

`-ls`
- выводит строку с описание файлам в формате `ls -dils`
`-fls file`
- как `-ls` но выводит в указанные файл 

`-exec command ;`
`-exec command arg1 arg2 arg3 ;`
- возвращает true, если команда возвращает `0`
- все последующие аргументы после команды считаются аргументами этой команды, пока не будет встречен аргумент `';'`
- строка `{}` замещается именем файла, который обрабатывается в данный момент
- команда выполняется в starting_point директории

`-exec command arg1 arg2 {} +`
- все подходящие файлы будут переданы в команду в `command` в виде одной последовательности позиционных параметров
- `{}` должен стоять в конце перед `+`
- всегда возвращает `true`

`-ok command ;`
- как `-exec`, но перед каждый запуском `command` спрашивает одобрения пользователя

`-delete`
- удалить файл
- если удаление было успешным - возвращает `true`, в противном случае выводит сообщение об ошибке, но продолжает выполнение
- если директория непуста, то удаление не состоится. В связи с чем автоматически включается опция `-depth`, чтобы было возможным удалять директории, содержимое которых тоже подлежит удалению

`-prune`
- если файл является директорией, то не обрабатывать его и его содержимое
- если указан `-depth`, то `-prune` не работает
- всегда возвращает `true`

`-quit`
- немедленно прекратить выполнение команды
___
### 7. Operators

Операторы в команде `find` интуитивно понятны, поэтому приводится только список доступных операторов с минимальными комментариями:

`( expr )`
- скобки позволяют изменить порядок операций

`! expr` или `-not expr`
- отрицание

`expr1 -a expr2` или `expr1 -and expr2` или `expr1 expr2`
- логичиское И

`expr1 -o expr2` или `expr1 -or expr2`
- логичиское ИЛИ

`expr1 , expr2`
- всегда выполняются оба выражения
- код выхода `expr1` не учитывается, результатом всего выражения будет код выхода `expr2`

___
### 8. Примеры

Наиболее интересные примеры для каждодневного применения:

1. Найти файл с именем `<name>` в директории `<dir>`:
``` bash
find <dir> -name <name> (по умолчанию expression == -print)
```

2. Найти файл соответствующий регулярному выражению `<re>` в директории `<dir>`:
``` bash
find <dir> -regex <re>
```

3. Найти все файлы в `<dir>`, которые являются обычные файлами и непустыми:
``` bash
find <dir> ! -empty -type f
```

4. Удалить все файлы в `<dir>` с расширением `.tmp` и вывести список удаленных файлов:
``` bash
find . -path '*.tmp' -delete -print
```

5. То же, но предаврительно спрашивать одобрения пользователя при удалении:
``` bash
find . -path '*.tmp' -ok rm '{}' \; -print
```
