___
Git предоставляет очень широкие возможности по работе с удаленными репозиториями. Однако, это не означает, что их обязательно нужно использовать все.

В этой статье я опишу:
- наиболее употребительный и общепринятый способ использования git
- наиболее удобные практики
- настройки, которые я предпочитаю использовать
___
### 1. Наиболее популярная практика

Наиболее распространенная система:
- централизованная: множество пользователей используют только один общий удаленный репозиторий, никто не лазит другу к другу в репозитории
- небольшое количество основных веток: одна стабильная ветка и небольшое количество остальных веток, которые существуют продолжительное время
```
A---B---C---D---E---F---G main
	 \       \
	  \       H---I---J---K---L topic
	   \
		M---------N---------O release 
```
Выше изображены следующие ветки:
- `main` - основная стабильная ветка, в которой находится разрабатываемый продукт
- `release` - ветка для поддержки определенного релиза, в нее иногда вносятся некоторые улучшения, но в целом она больше не развивается
- `topic` - нестабильная ветка, куда все разработчики вносят свои изменения

Вот для такой системы хорошо применимы, описанные далее приемы.
___
### 1.  Настройки git

>[!tip]
>По умолчанию главный репозиторий будет назван `origin` и оыбчно нет смысла изменять это имя.

Обязательно нужно настроить имя для главной ветки:
- `git config --global init.defaultBranch main`

>[!note]
>Можно настроить имя как в репозитории, но тогда возможно понадобиться перебивать некоторые алиасы, что хуже. Лучше всегда использовать одно имя и я остановился на имени main.

Я не нахожу большого смысла в использовании команды `pull`, а также upstream-веток вообще. Мне кажется что эта часть git слишком переусложнена, при очень небольших преимуществах. Вместо pull я собираюсь использовать следующие команды:
```bash
git fetch
git checkout fix
git rebase origin/main
```
Всегда явно указывать refspec в push. Чтобы это гарантировать, нужно прописать переменную в config:
- `git config --global push.default nothing`
Так как одновременно пушить несколько веток я не собираюсь, то нет ничего сложного в том, чтобы написать полный refspec:
```bash
git checkout fix
git push origin @:main
```

>[!note]
>Возможно, в будущем я пересмотрю данную практику, но тогда улучшение будет оформлено отдельной статьей.

___
### 2.  Особенности клонирования

При работе в такой системе помимо долгоживущих веток будут существовать еще огромное множество веток для пулреквестов, которые будут только загромождать репозиторий.

Прежде всего нужно склонировать репозиторий с опцией `--single-branch`. Тогда при клонировании будет выкачена только основная ветка:
```bash
git clone --single-branch <repository> <directory>
```

Затем нужно добавить остальные ветки, но только те с которыми предстоит работать. Это можно сделать с помощью команды `git remote add`, но проще прописать их вручную в файле `.git/config`:
```
[remote "origin"]
	url = git@github.com:<repo>.git
	fetch = +refs/heads/master:refs/remotes/origin/main
	fetch = +refs/heads/topic_1:refs/remotes/origin/topic_1
	fetch = +refs/heads/topic_2:refs/remotes/origin/topic_2
```
После чего выполнить:
```bash
git fetch
```
Все нужные ветки окажутся в репозитории. Однако для них нужно будет вручную еще создать локальные ветки.

Так как удаленный репозиторий всего один, то в дальнейшем будет всегда достаточно команды `git fetch` без аргументов.
____
### 3. Совместная работа над одной веткой

Иногда нужно поработать над одной веткой двум разработчикам: `dev1` и `dev2`.
Происходит это следующим образом:
- `user1` создает ветку `user1/fix` и пушит ее:
```bash
git push --set-upstream origin user1/fix
```
- `user2` добавляет имя ветки в `.git/config` и также скачивает ее (fetch)
- когда работа будет закончена `user1` сделает pull-request ([[git - pull request]])

Ветку можно удалить из удаленного репозитория:
```bash
git push -d origin user1/fix
```
Чтобы удалить только из локального репозитория:
- нужно удалить запись из файла `.git/config`
- нужно удалить файлик `refs/remotes/origin/user1/fix`
___
### 4. Внесение изменений

Обычная практика внесения изменений в ветку `topic` следующая:
```
A---B---C---D---E---F---G main
     \
	  H---I---J---K---L topic
				   \
					M---N fix
```
1. Создаем ветка `fix` на конце ветки `topic`
```bash
git checkout topic
git checkout -B fix
```
2. Вносим все необходимые изменения в ветку `fix`
3. Выкачиваем последние изменения для ветки `topic` с помощью fetch:
```bash
git fetch
```
4. Перебазируем ветку `fix` снова на самый конец ветки `topic` ([[git - rebase]]):
```bash
git rebase topic
```
5. Выполняем пуш ветки fix:
```bash
git push origin @:main
``` 
6. Удалить уже ненужную ветку
```bash
git checkout main
git branch -D fix
``` 
___
### 5. Внесение изменений через pull-request

Как правило, push недопустим и следует использовать pull-request ([[git - pull request]]).
Тогда в репозитории нужно выполнить только следующие действия:
- создать ветку и запушить ее
- выполнить все действия по созданию, одобрению, мержу и закрытию пулл-реквеста на сервисе
- удалить ветку локально
___
### 6. Перенос изменений из master в topic

Допустим у нас есть долгоживущая ветка topic.
```
A---B---C---D---E---F---G---H---I---J---K---L main
	 \       
	  M---N---O---P---Q---R---S---T---U---V topic
```

Когда-нибудь в будущем планируется вмержить ветку topic в main и чтобы этот процесс не был слишком сложным, нужно периодически переносить изменения из main в topic.

Даже если topic не планируется мержить в main, а только переность в main отдельные изменения - все равно важно, чтобы main и topic расходились как можно меньше.

Для решения это задачи используется обычный merge изменений:
```bash
git checkout topic
git merge main
```
В результате topic будет актуален, а main - не измениться
```
A---B---C---D---E---F---G---H---I---J---K---L main
	 \                                       \
	  M---N---O---P---Q---R---S---T---U---V---W topic
											  ^
											  merge commit
```

___
### 7. Перенос изменений из topic в master

Для переноса изменений из topic в master рекомендуется использовать cherry-pick ([[git - cherry-pick]]).

```bash
git checkout main
git cherry-pick -x <commit-hash-code>
```
Неплохо бы в сообщении к коммиту добавить пояснительную запись, из какого коммита он был cherry-picked.
