___
В bash есть два вида массивов:
- array (integer-indexed array) ->  далее просто массивы
- associative array
___
### 1. Массивы

Особенности массивов в bash:
- В bash массивы разреженные. Т.е. в массиве могут быть установлены только элементы с индексами 2, 3 и 42.
- Индексация элементов массивов начинается с 0.
- Массив в bash это не строка, скорее обычную строковую переменную следует понимать как массив из одного элемента.
##### 1.1. Присваивание элементов
Пример: `arr[3]="abc"` 
- Так как массивы разреженные, то не стоит беспокоиться о выходе за границы массива;
Пример: `arr=( Quebec Ontario Manitoba )`
Пример: `arr=( [0]=a [1]=b [9]=c )`
- можно задать сразу весь массив;

>[!note]
>`arr="abc"` -> ровно то же самое, что и `arr[0]="abc"` 
##### 1.2. Получение значения элемента
Пример: `${arr[3]}
Пример: `${arr[-1]}` (это обращение к последнему элементу)
- Здесь фигурные скобки обязательны!
##### 1.3. Получение всех элементов
Пример: `${arr[*]}` и `${arr[@]}`
- Результат будет получен в виде строки значений элементов, разделенных пробелами;
- В случае с символом `*` (asterisk) результат будет получен как одно слово (хоть и содержащее пробелы). В случае с символом `@` (at-sign) полученный результат будет дополнительной разделен на слова;

```bash
arr=( Quebec Ontario Manitoba )
printf "%s\n" "${bar[*]}"  # кавычки обязательны!
# вывод
Quebec Ontario Manitoba

printf "%s\n" "${bar[@]}"
# вывод
Quebec
Ontario
Manitoba
```
##### 1.4. Получение всех индексов
Пример: `indices=( "${!arr[@]}" )`
- таким образом можно будет получить массив всех индексов в `arr`
##### 1.5. Длина массива
Пример: `${#arr[@]}`
- Таким образом можно получить количество элементов в массиве, причем даже для разреженного массива!
Иногда нужно получить реальную длину разреженного массива, т.е. узнать номер его последнего индекса. Это можно сделать следующим образом:
```bash
indexes=( "${!arr[@]}" )  # получить массив всех индексов
i="${indexes[-1]}" # получить индекс последнего элемента в массиве
```
##### 1.6. Удаление
Пример: `unset arr`
- удаление всего массива
Пример: `unset arr[3]`
- удаление заданного элемента массива
##### 1.7. push back
Пример: `arr[${#arr[@]}]=elt`
- Такой способ годится только для неразреженных массивов;
Пример: `province+=( elt1 )`
Пример: `province+=( elt2 elt3 )`
- Работают даже в разреженных массивах
##### 1.8. Получение подмассива
Пример: `"${arr[@]:offset:length}"`
- таким образом можно получить подмассив длинной `length`, начинающийся с элемента с индексом `offset`
Пример: `"${arr[@]: -offset:length}"`
- Можно задавать `offset` от конца массива, но при этом обязателен дополнительный пробел, чтобы избежать путаницы с конструкцией `:-`
##### 1.9. Экспорт
Пример: `export arr`
- Таким образом будет экспортирован весь массив;
- Экспортировать отдельный элемент нельзя: `export arr[2]` -> `bash:export: 'baz[2]': not a valid identifier`
##### 1.10. Итерирование

Простой вариант итерирования по массиву:
```bash
arr=( [1]=Quebec [3]=Ontario [4]=Manitoba )

for elt in ${arr[@]}
do
    echo $elt
done

# вывод
Quebec
Ontario
Manitoba
```

Если мы хотим вывести индексы:
```bash
arr=( [1]=Quebec [3]=Ontario [4]=Manitoba )

indices=( ${!arr[@]} )
for (( i=0; i<=${indices[-1]}; ++i ))
do
    if [ -v arr[$i] ]
    then
        printf "index: %-3s %s\n" $i ${arr[i]}
    else
        printf "index: %-3s <unset>\n" $i
    fi
done
```
```text
# вывод
index: 0   <unset>
index: 1   Quebec
index: 2   <unset>
index: 3   Ontario
index: 4   Manitoba
```

___
### 2. Ассоциативные массивы

В целом принципы использования ассоциативных массивов такие же как обычных, посему здесь я перечислю только различия:

Отличия ассоциативных массивов:
- Ассоциативные массивы перед использованием нужно декларировать следующим образом: `declare -A asar`
- В ассоциативных массивая в качестве ключа выступает строка:
   `asar["gene"]="smart"`
   `echo asar["gene"]`
   `echo asar[gene]` -> можно и без кавычек
