___
Сmake предоставляет пользователю следующий набор команд для кастомных задач:
1. `add_custom_command( OUTPUT ... )` -> аналог make-правила (за тем исключением, что такое правило нельзя вызывать напрямую)
2. `add_custom_target( ... )` -> аналог фальшивого make-правила (может ничего не генерировать, а самое главное - всегда выполняется)
3. `add_custom_command( TARGET ... )` -> добавление команды к существующей цели
4. `execute_process( ... )` -> выполнение команды на этапе конфигурации

___
### 1. Создание кастомной цели

Добавить кастомную цель можно с помощью команды:
```
add_custom_target(targetName [ALL]
	[command1 [args1...]]
	[COMMAND command2 [args2...]]
	[DEPENDS depends1...]
	[BYPRODUCTS [files...]]
	[WORKING_DIRECTORY dir]
	[COMMENT comment]
	[VERBATIM]
	[USES_TERMINAL]
	[SOURCES source1 [source2...]]
)
```
Замечания:
- Кастомная цель всегда считается устаревшей и всегда требует обновления.
- Кастомная цель будет обновлена либо в случае особого запроса, либо если какая-то другая цель, которая зависит от нее, требует обновления.
- Во время обновления кастомной цели команды выполняются в том порядке, в котором они указаны в `add_custom_target()`

Аргументы:
- Флаг `ALL` - делает все цели зависимыми от этой кастомной цели.
- `DEPENDS` - список файловых зависимостей, т.е. файлов, от которых зависит данная кастомная цель.
	- В `DEPENDS`следует перечислять только абсолютные пути.
	- Если кастомная цель зависит от других целей, то их не нужно перечислять в `DEPENDS`. Для зависимостей от целей существует команда: `add_dependencies()`
- `BYPRODUCTS` - список файлов, сгенерированных кастомной командой.
- `COMMENT` - коммент, который будет выведен в консоль прямо перед обновлением цели (увы, это неточно)
- `SOURCES` - просто список файлов, которые связаны с кастомной целью. Кастомная цель обновляется всегда и эти файлы не влияют на ее обновление.

Кастомная цель в том числе может запускать только что собранные исполняемые файлы. Существующая цель может быть использована либо вместо команды, либо в команде или аргументе команды с помощью генераторного выражения `$<TARGET_FILE:executabletargetname>`. В обоих случае cmake автоматически создает зависимость.

___
### 2. Добавление кастомной команды к цели

Можно добавить еще одну команду к существующей цели `targetName` с помощью команды:
```
add_custom_command(TARGET targetName buildStage
	COMMAND command1 [args1...]
	[COMMAND command2 [args2...]]
	[WORKING_DIRECTORY dir]
	[BYPRODUCTS files...]
	[COMMENT comment]
	[VERBATIM]
	[USES_TERMINAL]
)
```
- `buildStage` определяет момент выполнения добавляемой команды и должна иметь одно из следующих значений:
	- `PRE_BUILD` - перед всеми правилами (но это неточно)
	- `PRE_LINK` - после компиляции, но до линковки
	- `POST_BUILD` - после всех правил

Можно добавлять несколько команд в одном вызове `add_custom_command()` и кроме этого можно несколько раз вызывать `add_custom_command()` для одной цели.

___
### 3. Команда по созданию файлов

Существует `OUTPUT`-форма команды `add_custom_command()`:
```
add_custom_command(OUTPUT output1 [output2...]
	COMMAND command1 [args1...]
	[COMMAND command2 [args2...]]
	[WORKING_DIRECTORY dir]
	[BYPRODUCTS files...]
	[COMMENT comment]
	[VERBATIM]
	[USES_TERMINAL]
	[APPEND]
	[DEPENDS [depends1...]
	[MAIN_DEPENDENCY depend]
	[IMPLICIT_DEPENDS <lang1> depend1
	[<lang2> depend2...]]
	[DEPFILE depfile]
)
```
- после ключевого слова `OUTPUT` должен быть указан один или неколько файлов, генерируемых командой
- если указан относительный путь, то подразумевается путь относительно текущей binary-директории.

В отличие от `TARGET`-формы такая команда не привязана ни к одной из целей. Напрямую такая команда так же не может быть вызвана. Такая команда будет выполнена только при выполнении двух условий:
- если какая-то цель ссылается на один из `OUTPUT`-файлов
- этот `OUTPUT`-файл отсутствует

Если файлы, которые использует кастомная команда, модифицированы - это не является основанием для вызова кастомной команды. Чтобы добавить такую зависимость нужно прописать исходные файлы в `DEPENDS`.

___
### 4. Кастомная команда на этапе конфигурации

Иногда нужно выполнить кастомные команды во время стадии конфигурации.

```
execute_process(COMMAND command1 [args1...]
	[COMMAND command2 [args2...]]
	[WORKING_DIRECTORY directory]
	[RESULT_VARIABLE resultVar]
	[RESULTS_VARIABLE resultsVar]
	[OUTPUT_VARIABLE outputVar]
	[ERROR_VARIABLE errorVar]
	[OUTPUT_STRIP_TRAILING_WHITESPACE]
	[ERROR_STRIP_TRAILING_WHITESPACE]
	[INPUT_FILE inFile]
	[OUTPUT_FILE outFile]
	[ERROR_FILE errorFile]
	[OUTPUT_QUIET]
	[ERROR_QUIET]
	[TIMEOUT seconds]
)
```
- Команды запускается немедленно.
- Если дано несколько команд, то стандартный вывод одной команды отправляется на ввод следующей. Вывод последней комнды отправляется в вывод cmake
- Stderr любой команды отправляется в вывод cmake

___
### 5. Кроссплатформенные команды cmake

Кастомные команды зачастую содержат много платформозависимого кода, например переименование файлов или перемещение файлов и т.д.

Пользователь может использовать в кастомных командах условную логику, чтобы сделать код платформонезависимым или воспользоваться специальными командами cmake:
```
cmake -E cmd [args...]
```
Cmake предоставляет большой набор `cmd`, среди которых:
- `touch`
- `rename`
- `copy`, `copy_directory`
- `remove`, `remove_directory`
- `make_directory`
- `compare_files`
- `md5sum`
- `echo`
- `tar`
- `time`
___
