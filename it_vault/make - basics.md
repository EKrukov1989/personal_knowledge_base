___
`make` - утилита для компиляции программ.

Команда make исполняет инструкции, которые прописаны в файле с именем makefile в текущей директории.

>[!note]
>При запуске make ищет файл с именем: `GNUmakefile` или `makefile` или `Makefile` (именно в таком порядке) и выполняет первый найденный файл.

___
###  1. Структура makefile

Файл makefile содержит набор правил (rules).

Каждое правило имеет следующую форму:
```make
target_1 target_2 ... : prerequisite_1 prerequisite_2 ...
	recipe
	...
	... (tab обязателен перед каждой строчкой рецепта)
```
или
```
target_1 target_2 ... : prerequisite_1 prerequisite_2 ... ; recipe
	recipe
	...
```

target - может представлять собой:
- имя файла, генерируемого в результате выполнения правила;
- имя действия (phony target), которое можно выполнить либо в качестве prerequisite, либо напрямую с помощью утилиты make.

prerequisite - может представлять собой:
- имя исходного файла
- имя какой-нибудь target (может быть имя файла, генерируемого каким-нибудь правилом, либо `phony target`)

recipe - набор bash-команд, который утилита make должна выполнить

Таким образом, каждое правило определяет:
- зависимости между targets и prerequisites
- правила создания (обновления) targets

makefile может состоить только из правил, однако всего предусмотрено пять типов элементов:
- explicit rules (это обычное полностью прописанное правило)
- implicit rules (правило определяется на основе имен файлов)
- variable definitions
- directives (специальные команды make)
- comments (начинается с `#`)
___
### 2. Как выполняется makefile

При запуске команды make без аргументов она выполняет только первое правило, или можно выполнить определенную target используя синтаксис: `make <target_name>`.

Makefile можно представить в виде дерева зависимостей (явных или неявных). Допустим makefile содержит следующие дерево зависимостей:
```
    main.cpp
   / 
app            utils.cpp
   \          /
	 utils.lib
              \
			   utils.h
clean
	 \
	  clean_libs
```

При запуске команда make выполняет следующее:
- читает makefile и строит деревья зависимостей
- определяет нужное поддерево в зависимости от target, которую нужно выполнить
- обновляет все дерево снизу вверх, т.е. от листьев к корню

Процесс обновления поддерева (характеризуемого определенным target) состоит из следующих этапов:
- прежде всего рекурсивно обновить все prerequisites
- если файл `target` отсутствует либо если файл target присутствует, однако он более старый чем prerequisites - выполнить recipe

Нужно предварительно обновлять пререквизиты исходя из следующих соображений:
- Допустим у нас есть следующая цепочка зависимостей:
```
a (2222) -> b (1111) -> c (3333) (где числа это таймстемпы)
```
В этой ситуаций файл `a` существует и он старше чем `b`, поэтому нет формальных причин его обновлять. Однако файл `b` на самом деле устарел и выяснить это можно только если рекурсивно обновить все пререквизиты.

___
### 3. Как `make` читает и парсит файлы

Make имеет два фазы работы.

В первой фазе:
- читает все makefiles
- запоминает все переменные и их значения
- запоминает все правила
- строит граф зависимостей

Во второй фазе:
- make вычисляет какие цели нужно обновить и запускает соответствующие рецепты

___
### 4. Разбиение длинных строк

С помощью backslash как в bash ([[bash - script processing]]):
```
target : prerequisite_1 \
         prerequisite_2 \
         prerequisite_3
```

___
### 5. Phony targets

Если в результате выполнения правила файл цели не создается, то такая цель называется `phony target`.
```
<phony_target_name> : prerequisite
	recipe
```
Если существует файл с названием `<phony_target_name>`и он более новый, через пререквизит, то `phony target` не будет выполнена. Чтобы избежать коллизии нужно прописать все `phony targets` в качестве пререквизитов к специальной цели:
```
.PHONY: <phony_target_name> ...
```

Так как phony target не имеет связанного с ней файла, то она всегда выполняется.

___
### 6. Forcing

Если цель не имеет пререквизитов и рецепта, а также если не существует файл с таким же именем как у цели, то такая цели будет выполняться всегда. А также все зависимые цели так же будут выполняться всегда. Например:
```
clean: FORCE
	rm $(objects)
FORCE:
(clean будет выполняются всегда, даже если существует файл clean)
```

___
### 7. Несколько `targets` в правиле

Синтаксис make предусматривает два вида разделителей:
- `:` -> для `independent targets`
- `&:` -> для `grouped targets`

При использовании разделителя `:` для каждой из перечисленных целей будет выполнен рецепт. Т.е. правило
```
target_1 target_2 : prerequisites
	recipe
```
эквивалентно следующему набору правил:
```
target_1 : prerequisites
	recipe

target_2 : prerequisites
	recipe
```

При использовании разделителя `&:` `recipe` будет выполнен только один раз, и ожидается, что в результате выполнения `recipe` все `targets` будут созданы.
