___
Основано на: [learn.microsoft.com - Translation units and linkage](https://learn.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=msvc-170)

Немного справочной информации:
##### C++ One Definition Rule (ODR):
- Внутри юнита трансляции любой символ может быть объявлен многократно, но определен всего один раз.
##### Юнит трансляции (translation unit):
- Каждый `.cpp`-файл прошедший этап препроцессирования становится юнитом трансляции. На этапе препроцессировния вместо директив `#include` вставляется содержимое заголовочных файлов (рекурсивно).

Решения распространенных проблем с объяснениями:
___
### 1. В заголовочном файле должен быть include guard или `#pragma once`

Допустим у нас есть объявление некоего класса, который мы хотим сделать общедоступным. Определим его в заголовочном файле `a.h` и используем в файле `b.cpp`:
Файл `a.h`:
```cpp
class A {};
```
Файл `b.cpp`:
```cpp
#include "a.h"
A a;
```
Это нормально скомпилируется, но при более сложной структуре могут возникнуть проблемы компиляции. Допустим у нас есть следующая структура:
Файл `a.h`:
```cpp
class A {};
```
Файл `c.h`:
```cpp
#include "a.h"
...
```
Файл `b.cpp`:
```cpp
#include "a.h"
#include "c.h"
A a;
```
Теперь в юните трансляции будет два определения класса A.
Чтобы этого избежать нужно в каждом заголовочном файеле прописывать `#pragma once`:
```cpp
#pragma once
class A {};
```

___
### 2. Определение функции должно быть в `.cpp`-файле

Однако `#pragma once` решает проблему только в пределах юнита трансляции. Допустим у нас есть два юнита трансляции:
Файл `a.h`:
```cpp
#pragma once
int foo() { return 42; }
```
Файл `b.cpp`:
```cpp
#include "a.h"
int bar() { return foo() }
```
Файл `c.cpp`:
```cpp
#include "a.h"
int baz() { return foo() }
```
Компиляция `b.cpp` -> `b.o` и `c.cpp` -> `c.o` будет успешной. Однако, если мы попробуем слинковать их вместе в исполняемый файл: `g++ b.cpp c.cpp`, то получим ошибку `multiple definition of foo()`.

Чтобы избежать этой проблемы следует вынести определение функции в `.cpp`-файл:
Файл `a.h`:
```cpp
#pragma once
int foo();
```
Файл `a.cpp`:
```cpp
#include "a.h"
int foo() { return 42; }
```
Теперь определение функции будет только в одном юните трансляции.

___
### 3. Определение метода класса должно быть в `.cpp`-файле

Программа может содержать несколько определений класса при условии что каждое определение находится в отдельном юните трансляции.

Файл `a.h`:
```cpp
#pragma once
class A { // определение класса в header-файле это нормально
public:
	static int a = 5; // ошибка! in-class initialization of non-const static member 
	const int b = 10; // нормально
	int foo() { return 42; }; // нормально
	int bar();
};

int A::bar() {return 42;} // ошибка! должно быть в .cpp-файле
```
___
### 4. Неконстантная статическая переменная-член должна быть определена в `.cpp`-файле

Если определить неконстантную статическую переменную-член в классе, то компилятор выкинет ошибку.
Файл `a.h`:
```cpp
#pragma once
class A {
public:
	const int b = 10; // нормально
	static int a = 5; // ошибка! in-class initialization of non-const static member 
};
```
Следует определить ее в соответствующем .cpp-файле:
Файл `a.h`:
```cpp
#pragma once
class A {
public:
	static int a;
};
```
Файл `a.cpp`:
```cpp
#include "a.h"
int A::a = 5;
```

___
### 5. Global variables

Вопросы про линковку глобальных переменных рассмотрены здесь:
- [[cpp - global variable linkage]]
