___
>[!note] Массивы рассматриваются в отдельной статье: [[bash - arrays]]

- Переменная - это параметр ([[bash - parameter]]), у которого есть имя.
- Все переменные храняться в виде строк (даже все параметры).
- Имена переменных - чувствительны к регистру.

___
### 1. Правила именования

Есть только два строгих правила именования переменных:
- имя переменной может содержать только буквы, цифры и знак подчеркивания.
- переменная должна начинаться с буквы или знака подчеркивания.

Для себя я приму следующие правила именования:
- для локальных переменных - строчные буквы, разделенные underscore
- для переменных окружения - то же, но с underscore в начале

```bash
PROMPT_DIRTRIM  # переменная окружения, установленная bash
prompt_dirtrim  # локальная переменная
_prompt_dirtrim  # пользовательская переменная окружения
```

___
### 2. Типы переменных

Все переменные деляться на два типа:
- переменные окружения (environment variables)
- переменные оболочки (shell variables)

В любой момент времени у нас есть два набора переменных. Например:
```
(environment variables)
A=1
B=2
C=3

(shell variables)
D=4
E=5
```

Все переменные находятся в едином пространстве имен, так что имена переменных окружения и оболочки не могут совпадать.

Ко всем переменным можно обращаться по имени, единообразно как для переменных оболочки, так и для переменных окружения.

Принципиальное (и единственное) различие между этими двумя типами переменных заключается в том, что при запуске нового процесса в оболочке, этот процесс получит копию только переменных окружения.

>[!note]
>Так как дочернему процессу предоставляется копия переменных окружения, поэтому он никак не сможет повлиять на переменные окружения в родительском процессе.

>[!note]
>Bash довольно часто создает дочерние процессы. Примеры:
>- при запуске сторонних утилит
>- при запуске скрипта
>- при использовании специального синтаксиса: `( cmd1; cmd2)`, `$( cmd )`
>- любые циклы также порождают отдельный процесс

___
### 3. Манипуляции с переменными

##### 3.1. Вывод переменных и их использование

Вывести значение переменной:
`echo $varname` , где `varname` - это имя переменной

Значение переменной (строка) всегда подставляется вместо `$varname` перед выполнением команды. Этот процесс называется expansion ([[bash - parameter and variable expansion]]).

Если переменной с именем `varname` не существует, то выражение `$varname` экспандится в пустую строку без сообщений об ошибке.

С помощью команды `printenv` можо вывести на экран все переменные окружения и их значения. С помощью команды `set` можо вывести на экран вообще все переменные, в том числе локальные.

>[!tip]
>Команда `set` выводит вообще все переменные, включая функции. Чтобы вывести только переменные, нужно ввести команду `(set -o posix; set)`
##### 3.2. Инициализация и присваивание

Присвоить значение переменной можно следующим образом: `varname=123`
Если переменной с таким именем не существует - будет создана новая переменная оболочки.

>[!warning]
>Между именем переменной и знаком присваивания и значением не должно быть пробелов.
##### 3.3 Удаление переменных

Удалить переменную можно с помощью команды `unset varname`
Если переменная с именем `varname` отсутствует, команда просто ничего не делает.
##### 3.3. Экспорт 

Переместить переменную оболочки в переменные окружения:
- `export varname`
Так же можно переместить и функцию:
- `export -f funcname`
Можно сразу объявить переменную, как переменную окружения:
- `declare -x varname=VALUE`
Удалить переменную из переменных окружения, при этом оставив ее среди локальных переменных.
- `declare +x varname` (причем это работает со всеми переменными окружения, т.е. любую переменную окружения можно сделать локальной)
Отправить все локальные переменные в экспорт:
- `set -k`

___
### 4. Переменные окружения при запуске оболочки

Из вышесказанного очевидно, что все изменения которые мы совершаем с переменными действуют только в текущей оболочке и в ее дочерних процессах.

Если мы хотим измененить или добавить переменные окружения таким образом, чтобы изменения сохранились для всех последующих вызовов оболочки - нужно внести изменения в специальные файлы

При запуске bash читает несколько файлов и исполняет несколько скриптов в сложном порядке. Файлы, которые могут быть использованы:
```
/etc/environment
/etc/profile
/etc/bash.bashrc
/etc/profile.d/...
~/bashrc
~/bashlogin
~/profile
~/pam_environment
```
На выходе из bash может быть еще вызван скрипт `~/bash_logout`.

Изменения в `/etc/environment` будут доступны system-wide.
Изменения в `~/pam_environment`  - только для соответствующего пользователя.

>[!note]
>При запуске bash читает множество скриптов и подгружает кучу переменных и функций. Однако все это в основном локальные переменные и на дочерние процессы они не влияют.

___
### 5. Дополнительные возможности

Длину строки переменной можно получить следующим образом:
- `${#var}`

Indirect Reference: можно получить значение переменной, через вторую переменную в которой хранится имя первой:
```bash
height=50
var="height"
echo ${!var}  # вывод 50
```

Специальный синтаксис, чтобы совершать различные действия  если переменная не установлена или пуста:

синтаксис | описание
-|-
`${var-default}` |Если переменная `var` не установлена, то результатом выражения будет `default`.
`${var:-default}` |Если переменная `var` не установлена или пуста, то результатом выражения будет `default`
`${var+alternate}` |Если переменная `var` установлена, то результатом выражения будет `alternate`
`${var:+alternate}` |Если переменная `var` установлена и непуста, то результатом выражения будет `alternate`
`${var=default}` |Если переменная `var` установлена, то ей будет присвоено `default` и результатом выражения будет `default`
`${var:=default}` |Если переменная `var` установлена и непуста, то ей будет присвоено `default` и результатом выражения будет `default`
`${var?message}`|Если переменная `var` не установлена, то `message` будет выведено в stderr и программа завершит работу с кодом 1.
`${var:?message}`|Если переменная `var` установлена и непуста, то `message` будет выведено в stderr и exit 1.


