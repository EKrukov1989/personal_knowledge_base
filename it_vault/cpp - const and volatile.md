___
Основано на:
- https://en.cppreference.com/w/cpp/language/cv.
- http://www.crossplatform.ru/node/183

В ней рассмматриваются в основном особенности волатильных объектов, так как константный объекты - вещь уже хорошо изученная.
___
### 1. Константные объекты

Константный объект не может быть модифицирован:
- Если модифицировать его напрямую, то это приведет к ошибке компиляции.
- Если попытка изменить константный объект каким-либо другим образом (например черех указатель), то это может привести к неопределенному поведению.

___
### 2. Волатильные объекты

Обычные переменные могут быть оптимизированы в процессе компиляции. Например, переменная может быть закэширована в регистре.

Компилятор производит оптимизации из расчета, что переменные могут быть изменены только из текущего потока. Если переменная может быть изменена извне, то подобная оптимизация может быть нежелательна.

Если отметить переменную как `volatile`, то при любом обращении к переменной она будет читаться из оперативной памяти или записываться в оперативную память.

Имеет смысл делать волотильными следующие переменные:
 - переменные которые могут быть измененые в процессе прерывания
 - переменные которые могут быть изменены из другого потока или другого процесса

Есть и другие ситуации, когда `volatile` может быть полезным:
```cpp
int counter = 0;
while (counter < 1000 * 1000)
{
	++counter;
}
```
Если не отметить `done` как `volatile`, то компилятор просто выкинет этот код как бесполезный, хотя программист собирался замедлить выполнение программы с помощью такого кода.

>[!note]
>Тема волатильности довольна обширная. Есть волотильные функции и правила применения тэтих функций. Но в этой статье это не рассматривается.

___
### 3. Константно-волатильные объекты

На первый взгляд кажется, что если объект константный, то нет смысла делать его волатильным. На самом деле такая ситуация возможна, если какой-то объект не предполагается изменять из программы, но он может быть изменен извне.

___
### 4. Как определить константные и волатильные объекты 

Существует два спецификатора типа:
- `const`
- `volatile`

Эти два спецификатор хоть и независимы, но логически взаимосвязаны, поэтому их часто называют `cv-qualifiers`. Далее станет понятно, что они еще и связаны со спецификатором `mutable`.

Любой тип в зависимости от набора этих спецификаторов может быть отнесен к одному из следующих четырех типов:
- `cv-unqualified`
- `const-qualified`
- `volatile-qualified`
- `const-volatile-qualified`

Константный объект - объект одного из следующих двух типов:
- объект, тип которого отмечен спецификатором `const`
- подобъект объекта, тип которого отмечен спецификатором `const` (за исключением подобъектов, которые отмечены как `mutable`)

Волотильный объект - объект одного из следующих двух типов:
- объект, тип которого отмечен спецификатором `volatile`
- подобъект объекта, тип которого отмечен спецификатором `volatile`
- `mutable` подобъект `const-volatil`объекта

Константно-волотильный объект - объект одного из следующих двух типов:
- объект, тип которого отмечен спецификаторами `const` и `volatile`
- подобъект `const volatile`объекта, если он не отмечен как `mutable`
- константный подобъект волатильного объекта
- волатильный подобъект константного объекта, если не отмечен как `mutable`

Примеры:

```cpp
#include "pch.h"

struct A
{
	int a = 0;
	const int b = 0;
	volatile int c = 0;
};

void print_type(std::string comment, const int&)
{
	std::cout << comment << " const"<< std::endl;
}
  
void print_type(std::string comment, int&)
{
	std::cout << comment << " cv-unqualified"<< std::endl;
}
  
void print_type(std::string comment, volatile int&)
{
	std::cout << comment << " volatile"<< std::endl;
}
  
int main()
{
	A obj_a;
	print_type("1", obj_a.a);
	print_type("2", obj_a.b);
	print_type("3", obj_a.c);
}
```

Вывод:
```
1 cv-unqualified
2 const
3 volatile
```