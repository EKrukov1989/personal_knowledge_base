___
Команда `git push` обновляет удаленные ссылки до состояния локальных ссылок, пересылая в удаленный репозиторий недостающие файлы.
___
### 1. Синтаксис:

`git push [options] [<repository> [<refspec>...]]
___
### 2. Push-refspec

push refspec -> спецификация, которая определяет какие ссылки запушить и каким образом.

Формат:
`[+]<src>:<dst>`
`<src>` -> обычно имя ветки, которую следует запушить, например `refs/heads/main`
`<dst>` -> ссылка в удаленном репозитории, которую следует обновить>, например `refs/heads/master`

Обновление состоиться только в следующих случаях:
- если возможен fast-forward merge
- если refspec начинается с `+`
- если в команде указана опция `--force`

`tag <tag>` означает то же самое, что `refs/tags/<tag>:refs/tags/<tag>`

Использование `+` в refspec или опции `--force` приводит к форс-пушу.
При обычном пуше если fast-forward merge невозможен, то пуш просто отменяется.
При форс-пуше если fast-forward merge невозможен, то история в удаленном репозитории будет переписана:

Например у нас есть следующая ситуация:
```text
remote repo "origin":
A---B---C---D---E "master"

this repo:
		  F---G "aux"
		 /
A---B---C "refs/remotes/origin/master"
```
Если использовать команду: `git push origin +aux:master`, то мы получим следующий результат:
```text
remote repo "origin":
A---B---C---F---G "master"
```
Т.е. коммиты `D` и `E` будут выброшены из истории.

>[!warning]
>Использовать force-push следует только в особых случаях.
>Никогда не следует прописывать форс-пуш в конфиге: `push = +<src>:<dst>`

___
### 3. Варианты применения

Есть несколько вариантов использования команды push:
- `git push [options] <repository> <refspec>`
- `git push [options] <repository>`
- `g it push [options]`
И логика их использования может быть довольно запутанной.
Например на логику влияет переменная `push.default`, которая может принимать 6 разных значений. В этой статье будут рассмотрены только два: nothing и simple (значение по умолчанию).
Далее подробно рассмотрены наиболее интересные варианты.
___
##### 3.1. Refspec в команде

В полном варианте команды пуш явно указывается и репозиторий и refspec.
Допустим у нас есть следующий набор веток:
```text
remote repo "origin":
A---B---C "master"

this repo:
		  D---E "aux"
		 /
A---B---C "refs/remotes/origin/master"
```

Мы хотим запушить ветку `aux` в ветку `origin/master`. Сделать это можно с помощь команды:
```bash
git push origin refs/heads/aux:refs/heads/master
( Причем текущая ветка - может быть любой )
```
Результат:
```text
remote repo "origin":
A---B---C---D---E  "master"

this repo:
A---B---C---D---D "aux"  "refs/remotes/origin/master"
```

Полный вариант команды push - универсален. Остальные варианты всего лишь 
добавляют удобства в наиболее часто используемых ситуациях.
___
##### 3.2. Без refspec в команде, но refspec в конфиге

Допустим что у нас такая же ситуация как в прошлом примере и мы хотим добиться того же, но с помощью команды без refspec, т.е. `git push origin`.

В этом случае команда попробует запушить текущую ветку, а refspec будет искать в конфиге. Если в конфиге определена refspec для текущей ветки, то команда будет выполнена успешно:
```
[remote "origin"]
	push = refs/heads/aux:refs/heads/master
```
___
##### 3.3. Без refspec, но с upstream-веткой

Если же refspec в конфиге не прописан, то далее логика определяется в зависимости от переменной `push.default`. Если `push.default=nothing`, то в результате мы получим сообщение:
```
fatal: You didn't specify any refspecs to push, and push.default is "nothing".
```
Так как `push.default=nothing` требует всего указывать refspec.

Если `push.default=simple`, то требования следующие:
- должна быть прописана upstream-ветка:
```
[branch "master"]
	remote = origin
	merge = refs/heads/master
```
- имя локально ветки должно совпадать с именем remote-ветки

В целом это возможно только при следующем вокрфлоу:
- пользователь всегда пушит в одну и ту же ветку (например `origin/master`)
- пользователь создает локальную ветку master (есть даже настройки, которые позволяют сразу указать настроить upstream-ветку)
- когда работа закончена, пушит ее в `master`

>[!note]
>Мне такой воркфлоу не подходит, так как я обычно одновременно веду несколько задач и мне нужно иметь несколько веток.

___
##### 3.4. Без repository

Если не указать в команде `<repository>`, то
- при наличии upstream-ветки будет использован remote, который указан в конфигурации upstream-ветки
- в противном случае будет использован `origin`
___
### 3. Опции

`-d, --delete`
- удалить все перечисленные ссылки из удаленного репозитория
- того же самого эффекта можно добиться если указать refspec без src -> `:<dst>`

`-f, --force`
- форс-пуш, описан выше

`-u, --set-upstream`
- можно запушить в удаленный репозиторий ветку, которой там еще нет
