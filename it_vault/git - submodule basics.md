___
Субмодули это очень важная и обширная тема. Однако есть два, различных варианта применения субмодулей:
##### Базовый вариант:

В базовом варианте субмодули разрабатывают отдельные команды.
От разработчика суперпроекта требуется только:
- скачать субмодули (возможно избирательно - скачать только нужные)
- обновить субмодули до актуальной версии
- изменить версию субмодуля в суперпроекте
##### Продвинутый вариант:

В продвинутом варианте одни и те же разработчики разрабатывают и субмодули и суперпроект. Для таких ситуаций git предлагает специальные возможности:
- изменение субмодулей
- одновременные коммиты субмодулей и суперпроекта

В данной статье я буду рассматривать только базовый вариант.
Кроме того, я не буду рассматривать вопросы добавления-удаления субмодулей, потому что это довольно редкая операция.
___
### 1. Общее устройств субмодулей

Основано на `man gitsubmodules`.

Пути и определения:
- superproject - репозиторий, в который встроен субмодуль
- `<work_dir>` -> рабочая директория суперпроекта
- `<subm_name>` -> имя субмодуля
- `<subm_path>`  -> путь к субмодулю, относительно `<work_dir>`

Для организации работы субмодуля используется сразу несколько дополнительных папок и файлов:

1. Рабочая директория субмодуля: `<work_dir>/<subm_path>`
Данная директория в основном ведет себя как обычная рабочая директория git. Одно из важных отличий - в этом директории вместо репозитория находится файл `.git`.

2. Файл `<work_dir>/<subm_path>.git` хранит путь к настоящей папке `.git`:
```
gitdir: ../.git/modules/`<subm_name>
```

3. Директория `<work_dir>/.git/modules/<subm_name>/`
Настоящий репозиторий субмодуля.

4. Файл `<work_dir>/.gitmodules` хранит список всех субмодулей и их данные:
```
[submodule "subm_name"]
	path = subm_path
	url = subm_url
```
Этот файл предназначен для распространения с другими файлами.

5. Файл `<work_dir>/.git/config` также хранит примерно те же данные, что и `.gitmodules`, но не предназначен для публикации. Например:
```
[submodule "subm_name"]
	url = subm_url
	active = true
```

___
### 2. Текущий статус

Команда `git submodule` выводит следующую информацию:
```
+1c5cfbcdab0f1076fa308a5ca9af45ae468584fc submodule_name (1c5cfbc)
```
А именно:
- `+` -> `HEAD` субмодуля находится не на том коммите, которые требует суперпроект.
- хэш-код коммита, которому соответствует HEAD субмодуля в данный момент
- имя субмодуля

Если все субмодули в актуальном состоянии, то перед хэш-кодами не должно быть никаких символов.
___
### 3. Основные команды

##### 3.1. Обычное клонирование репозитория

Клонирование выполняется командой:
- `git clone <repository> [<dir>]`
В результате:
- создаются директории для субмодулей, но сами субмодули не скачиваются.
- cубмодули неинициализируются
Фактически после обычного клонирования о наличии субмодулей можно догадаться только по файлу `.gitmodules`

Чтобы начать пользоваться субмодулями их следует проинициализировать командой:
- `git submodule init`
В результате:
- данные из `.gitmodules` будут перенесены в `.git/config`

>[!tip]
>В этот момент можно сделать какие-нибудь манипуляции с конфигом, до того как обновлять субмодули. Например, сделать какие-то модули неактивными. Для этого нужно изменить параметр `active` в конфиге на `false`.

Чтобы обновить субмодули, нужно выполнить команду:
- `git submodule update`
В результате:
- субмодули будут скачаны и помещены в директорию `<work_dir>/.git/modules/<subm_name>/`
- рабочая директория субмодуля будет приведена с соответствие с текущей версией суперпроекта
___
##### 3.2. Клонирование репозитория сразу с субмодулями

В целом, если проект небольшой и не нужно экономить место, то можно склонировать суперпроект сразу со всеми субмодулями:
- `git clone --recurse-submodules <repository> [<dir>]`
Тогда все субмодули будут приведены в рабочее состояние сразу после клонирования.
___
##### 3.3. Обновление субмодулей

Допустим у нас есть следующая история:
```
A---B---C---D---E---F---G---H---I---J superproject
K---L---M---N---O---P submodule_1
Q---R---S---T---U submodule_2
```
История суперпроекта и субмодуля соотносяться следующим образом:
```
A---B---C---D---E---F---G---H---I---J superproject
		M---N---N---N---N---N---N---N submodule_1
		            R---R---R---U---U submodule_2
```
Т.е. в проект постепенно добавляются новые субмодули и периодически они обновляются.

>[!note]
>Предполагается, что субмодули добавляет и изменяет кто-то другой. Наша задача - толлько правильно обновить суперпроект.

### B -> C
Допустим наш суперпроект локально находится на коммите B.
Мы вытаскиваем коммит С и обновляем рабочую директорию с помощью следующих команд:
```bash
git fetch
git rebase origin/main
```
До этого субмодули не использовались, поэтому только сейчас у нас появляется файл
`.gitmodules`, а также рабочая новая рабочая директория для `submodule_1`.

К сожалению, этого недостаточно, так как `submodule_1` не склонирован.
Нужно еще вручную выполнить следующие команды:
```bash
git submodule init
git submodule update
```
### C -> D
Допустим мы находимся на коммите С, a origin уже содержит коммит D. В коммите D `submodule_1` изменил версию. Нужно снова воспользоваться командой:
- `git submodule update`
### E -> F
Допустим мы находимся на коммите E и  хотим перейти на F. В коммите F добавляется еще один подмодуль - `submodule_2`. Здесь будет недостаточно `git submodule update`, так как будет обновлен только `submodule_1`. Нужно выполнить команду
- `git submodule update --init`

### Вывод:
При работе с субмодулями, чтобы всегда быть увереным что рабочая директория и все субмодули приведены в рабочее состояние нужно выполнять следующую последовательно команд:
```bash
git fetch
git rebase origin/main
git submodule update --init --recursive
```
Есть, конечно, и более короткие варианты, но это уже детали.
___
##### 3.4. Переключение между версиями

Допустим у нас есть локальный репозиторий и мы хотим переключаться между версиями и хотим чтобы субмодули были приведены в соответствующее состояние после каждого чекаута. Добиться этого можно двумя способами:
```bash
git checkout <commit>
git submodule update
```
или
```bash
git checkout --recurse-submodules <commit>
```

>[!warning]
>Это может не работать в сложных случаях, например при переименовании субмодуля или его переключении на другой url.
