___
Make обладает своими переменными (далее - переменные make).

Посмотреть список установленных по умолчанию переменных можно с помощью команды `make -p` ( в директории без makefile).
___
### 1. Основные особенности

Особенности переменных make:
- Все переменные make хранят текстовые строки
- Имя переменной может состоять из любой последовательности символов кроме whitespaces и `:`,`#`,`=` 
- Имена переменных чувствительны к регистру
- При запуске make все переменные оболочки становятся переменными make
- Переменные make НЕ экспортируются и будут не видны при запуске рецептов

___
### 2. Присваивание переменных

Присвоение переменных немного отличается от присвоения в bash в плане обращения с пробелами:
```
(далее с помощью $ отображен символ перехода на новую строку)
make_var = value$       (значение переменной - "value")
make_var = value $      (значение переменной - "value ")
make_var = value   $    (значение переменной - "value ")
make_var = "value   "$  (значение переменной - "value   ")
```

Переменной можно присвоить целый рецепт или даже целое правило.

Проверить определена переменная или нет можно с помощью такой конструкции:
```
ifndef my_var
$(error my_var is not set)
endif
```

___
### 3. Раскрытие переменных

Обратиться к переменной можно следующим образом:
- `$x` (только если имя переменной состоит из одной буквы)
- `$(var)` или `${var}`

>[!warning]
>Если в имени переменной более одного символа, то скобки обязательны!
>Желательно использовать скобки всегда.

Обращаться можно где угодно:
- в цели
- в пререквизите
- в рецепте
- в правой части присвоения

Однако результат раскрытия переменной может быть разным в зависимости от способа присваивания и в зависимости от контекста.

Make имеет два этапа работы:
1. Чтение makefiles, запоминание переменных и правил, построение дерева зависимостей
2. Исполнение тех рецептов, которые требуется исполнить

Итого раскрытие переменных зависит от контекста:
- Переменные в целях и пререквизитах раскрываются на первом этапе - непосредственно в процессе парсинга.
- Переменные в рецептах раскрываются на второй фазе, в этот момент все makefiles уже прочитаны и значения всех переменных окончательны.
- Переменные определяются (и переопределяются) на первой фазе в процессе чтения. Но об этом подробнее в следующем разделе.

Пример:
```
a = 1
action : action_$a  
	@echo "action-recipe:"
	@echo $^
	@echo $a

a = 2
action_1 : action_$a
	@echo "action_1-recipe:"
    @echo $^
	@echo $a

action_2 :
	@echo "action_2-recipe:"
	@echo $a
```
Вывод будет следующим:
```
action_2-recipe:
2
action_1-recipe:
action_2
2
action-recipe:
action_1
2
```
Цели и пререквизиты определяются на первой фазе (во время чтения), а рецепты во время второй.
Здесь видно, что внутри рецепта значение всегда `$a == 2`, в то время как значение пререквизитов в правилах определяется во время парсинга.

___
### 4. Способы присваивания

Существует два способа присваивания.
##### Simply expanded variables 

Переменная инициализируется с помощью знака `:=` или `::=`.
Такая переменная получает конечное текстовое значение непосредственно в момент парсинга. Все переменные в правой части присваивания раскрываются и им присваивается то значение, которое они имеют в этот момент. Например:
```
a = $b
c ::= $a
b = qwerty

В результате:
a == b == qwerty
c == <empty_string>, потому что в момент присваивания с, b было пустым, и соответственно a было пустым.
```
##### Recursive expansion

Переменная инициализируется с помощью знака `=`.
При таком присваивании переменные в правой части не раскрываются в момент присваивания, а раскрываются в момент обращения.
Например:
```
			(в этот момент $a -> <empty>)
a = $b      (в этот момент $a -> <empty>, так как b -> <empty>)
b = $c      (в этот момент $a -> <empty>, так как b и с -> <empty>)
c = qwerty  (в этот момент $a -> qwerty, так как b и с -> qwerty)
```

Разница между двумя разными типами присваивания:
```
a = 1
b := $a
c = $a    (здесь b == 1, c == 1)
a = 2     (здесь b == 1, c == 2) 
```
##### Conditional variable assigment

Переменная инициализируется с помощью знака `?=`.
Такое присваивание аналогично рекурсивному присваиванию, но происходит  только если переменная на данный момент неопределена.
### 5. Appending

Добавление происходит с помощью знака `+=`.
```
a += text
```
Если переменная уже определена, то перед текстом вставляется пробел.

Если переменная была определена как`simply`, то после добавления она также останется `simply`:
```
x = 1
y = 2
a := $x
a += $y
x = 3
y = 4
(здесь a == 1 2)
```
Если переменная определена как `recursive`, то после добавления она останется `recursive`:
```
x = 1
y = 2
a = $x
a += $y
x = 3
y = 4
(здесь a == $x $y, после раскрытия 3 4)
```

Если переменная неопределена, то после добавления будет определена как `recursive`.
___
### 6. Автоматические переменные

Переменные в целях и пререквизитах раскрываются на первой стадии, а в рецепте - во второй. Поэтому если использовать обычные переменные, то их значения могут разойтись:
```
a = abc
target : $a
	$echo $a
a = def
(здесь $a в пререквизите == abc, а в рецепте - def)
```
Чтобы получить именно то значение, которое раскрыто для пререквизита и цели, нужно использовать автоматические переменные:
`$^` - найденные пути к `prerequisites` 
`$@` - найденные пути к `targets`
`$<` - найденные пути к первому `prerequisite` 
