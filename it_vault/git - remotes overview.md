___
Тема обширная, а самое главное содержит кучу новых терминов, которые требуют дполнительного пояснения. Поэтому в этом разделе будет дано описание всех основных терминов в ненавязчивой повестововательной форме.

___
### 1. Терминология
___
##### 1.1. Remote

Remote <-> удаленный репозиторий.
Удаленный репозиторий может быть git-сервером, а может быть просто таким же обычным репозиторием, даже на той же самой машине. Т.е. для определенного репозитория любой другой репозиторий кроме него самого - называется удаленным (remote).

Чтобы работать с удаленным репозиторием его нужно зарегистрировать (добавить). Т.е. присвоить ему имя, набор адресов и другие настройки.
Вся эта информация хранится в файле `.git/config`:
```
[remote "origin"]
	url = git@github.com:<repository_name>.git
	fetch = +refs/heads/*:refs/remotes/origin/*
```
Т.е. технически для git удаленный репозиторий представляет собой только такую запись.
___
##### 1.2. Remote-ветка

Remote-ветка - это ветка, которая находится в удаленном репозитории.
Допустим в удаленном репозитории `r1` есть локальная ветка `aux`. Если в нашем репозитории `r1` обозначен как`origin`, то мы можем обращаться к remote-ветке `aux` с помощью имени `origin/aux`.

Remote-ветка не имеет технического воплощения в репозитории. Когда мы говорит о remote-ветке - мы говорим именно о сущности находящей в другом репозитории. Мы знаем только имя этой ветки.
___
##### 1.3. Remote-tracking-ветка

Remote-tracking-ветки технически представляют собой то же самое, что и обычные ветки, только находятся по другому адресу: `.git/refs/remotes/<remote>/<branchname>`. Внутри файла remote-tracking-ветки так же расположен только хэш-код коммита, на который она указывает.

Remote-tracking-ветка представляет собой локальную копию соответствующей remote-ветки. 
Remote-tracking-ветку можно чекаутить, но в нее нельзя делать коммиты и каким-то образом изменять.
Remote-ветку можно только обновлять, чтобы забрать изменения из remote и привести remote-tracking-ветку в соответствие с remote-веткой.

Remote-tracking-ветка может иметь имя, отличное от соответствущей remote-ветки.
Связь между remote-веткой и remote-tracking-веткой определяется через refspec в `.git/config`. Например: `fetch = +refs/heads/*:refs/remotes/origin/*`
___
##### 1.4. Tracking-ветка

Tracking-ветка - это локальная ветка, которая связана с соответствующей remote-веткой.
Проявляется эта связь в том, что если `git pull` на tracking-ветке, то git автоматически вытащит и вмержит изменения из соответствующей remote-tracking-ветки.

Технически tracking-ветку от обычной локальной ветки отличает запись в `.git/config`.
Например:
```
[branch "user/evg/aux_b1"]
	remote = origin
	merge = refs/heads/user/evg/aux_b1 (это upstream branch)
```
___
##### 1.5. Upstream-ветка

Upstream-ветка это относительное понятие. Если у нас есть некая tracking-ветка, то связанную с ней remote-ветку принято называть upstream-веткой.
___
##### 1.6. Stale ветка

Stale-ветка - remote-tracking-ветка, которая уже удалена в соответствующем удаленном репозитории, но все еще сохранилась локально.
___
##### 1.7. Default branch

Удаленный репозиторий может иметь ветку по умолчанию, имя такой ветки прописано в
`.git/refs/remotes/<name>/HEAD`. Если ветка по умолчанию прописана, то можно использовать имя репозитория, вместо полного имени ветки по умолчанию.
Т.е. если имя удаленного репозитория - `origin`, а ветка по умолчанию - `origin/master`, то можно использовать `origin` вместо `origin/master`.
___

### 2. Основной функционал
___
Прежде чем приступить к описанию инструментов git для работы с удаленными репозиториями следует описать основные задачи, которые эти инструменты должны выполнять. Такие задач в целом всего две:
- получение информации из удаленный репозиторий и удобное ее представление
- внесение изменения в удаленный репозиторий

Все активное взаимодействие с удаленным репозиторием сводится к двум командам:
- fetch  (pull - это немного дополненный вариация fetch)
- push
Остальные же инструменты нужны чтобы настроить работу этих команд.

Но прежде чем подробно рассматривать работу fetch и push, рассматрим основные команды, связанные с настройкой и управлением удаленным репозиторием:

`git remote add <name> <URL>`
- добавить удаленный репозиторий `<url>` под именем `<name>`
- (обычно репозиторий клонируется и добавлять ничего не нужно)

`git remote show [-n] <remote>`
- выводит информацию об удаленном репозитории, в том числе всю информацию о ветках

`git push --set-upstream <remote> <local_branch_name>`
- можно добавить в репозиторий новую ветку:

`git push --delete <remote> <branch>`
- удалить ветку из удаленного репозитория

`git remote prune [-n | --dry-run] <repository>`
- избавиться от stale-веток:

##### 2.1. Fetch

Допустим у нас есть следующий набор веток:
```text
Удаленный репозиторий "origin"

A---B---C---D---E "master" (remote branch)

Локальный репозиторий

A---B---C "main" (tracking branch)
		  "refs/remotes/origin/main" (remote-tracking branch)
```
В ветке `origin/master` на два коммита больше, так как локальный репозиторий давно не связывался с удаленным. При вызове команды fetch происходит следующее:
- remote-tracking branch обновляется и теперь в ней записан хэш коммита `E`
- объекты коммитов `E` и `D`, а также другие объекты отсутствующие в локальном репозитории забираются и сохраняются в локальном репозитории
Результат:
```text
Локальный репозиторий

		  D---E "refs/remotes/origin/main" (remote-tracking branch)
		 /
A---B---C "main" (tracking branch)
		  
```
##### 2.2. Push

Допустим у нас есть ветка следующий набор веток:
```text
Удаленный репозиторий "origin"

A---B---C "master" (remote branch)

Локальный репозиторий

		  D---E "main" (tracking branch)
		 /
A---B---C "refs/remotes/origin/main" (remote-tracking branch)
```
У нас есть два коммита (`D` и `E`) в ветке `main`, которые нужно запушить в ветку `origin/master`.
При вызове команды push происходит следующее:
- из ветки `origin/master` забираются изменения в `remote-tracking branch`
- если возможен fast forward merge - происходит попытка обновить ветку в удаленном репозитории
- в противном случае пользователю будет предложено сначала забрать изменения, смержить свои изменения с этими изменениями и потом продолжить работу





