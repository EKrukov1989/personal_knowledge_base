___
Если в правилах упоминается некоторый файл, но для этого файла нет явного правила, то make пробует найти для файла неявные правила. Вывод о возможности применения неявных правил к файлу осуществляется на основе его имени.

Чтобы воспользоваться неявными правилами достаточно написать правило без рецепта. Например:
```
main.o : main.cpp

Будет выполнено:
g++ -c -o main.o main.cpp
```
Или не писать правила вовсе. Например:
```
app : main.o
	g++ main.o -o app

Будет выполнено:
g++    -c -o main.o main.cpp
g++ main.o -o/exec
```

Make способен составлять даже цепочки из неявных правил. Т.е. если в make знает как преобразовать `name.a -> name.b` и `name.b -> name.c`, то он сумеет неявно преобразовать 
`name.a` в `name.c`. Промежуточные файлы make по умолчанию удаляет.

Каждое неявное правило содержит:
- паттерн для цели
- паттерны для пререквизитов
- шаблон рецепта

Может быть множество неявных правил для одного и того же паттерна цели. Например файл `main.o` может быть получен из файла `main.c` или `main.cpp`. Будет применено правило, для которого существуют пререквизиты, или оно могут быть созданы на основе других неявных правил

>[!warning]
>Пререквизиты не влияют на выбор неявных правил.
>Даже если есть правило: `main.o : main.cpp (без рецепта)`, но make обнаружит файл `main.c`, то будет использован `main.c`, просто потому что это неявное правило прописано раньше.

___
### Каталог встроенных неявных правил

Make имеет большое количество встроенных неявных правил.
- Можно посмотреть список неявных правил если выполнить команду `make -p` в каталоге без `makefile`.
- Или можно отменить все неявные правила с помощью опций: `-r`,  `--no-builtin-rules`

Для С++ интересны следующие неявные правила:
```make
n.o : n.cpp
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c n.cpp
	(По умолчанию это раскрывается в g++ -c -o n.o n.cpp)

n : n.o
	$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)
	(По умолчанию это раскрывается в "g++ -o n n.cpp")
```

___
### Примеры использования неявных правил на практике

На самом деле `g++` компилирует из `.cpp` файлов исполняемый файл, если не указано никаких опций. Поэтому нет особого смысла использовать неявные правила.

Например, есть исходные файлы:
```
- main.cpp util.cpp
- util.h defs.h
```
Тогда следующее правило сделает ровно то, что от него требуется:
```
app : main.cpp util.cpp util.h defs.h
	g++ -o app main.cpp util.cpp
```
Создаст объектные файлы, слинкует их и удалит потом.