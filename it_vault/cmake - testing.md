___
С помощью сmake можно собирать тестовые приложения (обычными методами).

**_Тестовое приложение**_ это обычный исполняемый файл. Результат выполнения тестов в нем проверяется исходя из его кода выхода или же стандартного вывода. По умолчанию, если тестовое приложение возвращает код выхода 0, то оно считается успешным.

**_Ctest**_ - специальный инструмент, который предназначен для запуска тестовых приложений и визуализации их результатов.

Если выполнить команду `ctest` в директории билда, то он прочитает список тестовых приложений и выполнит их все. Список тестовых приложений записан в файле `CMakeTestfile.cmake`.

Чтобы автоматически создать `CMakeTestfile.cmake` средствами cmake на этапе конфигурации, следует воспользоваться командой `enable_testing`:
```cmake
cmake_minimum_required(VERSION 3.25)
project(App LANGUAGES CXX)
enable_testing()
```
Желательно вызывать эту команду в корневом `CMakeLists.txt`, тогда и `CMakeTestfile.cmake` будет создан в корневой директории билда.

Для добавления тестового приложения в этот список существует следующая команда:
```
add_test(NAME testName
	COMMAND command [arg...]
	[CONFIGURATIONS config1 [config2...]]
	[WORKING_DIRECTORY dir]
)
```
- `command` -> команда, которая запускает тест; тест считается пройденным, если эта команда возвращает 0.
- В команде можно указать полный путь к исполняемому файлу или же имя цели этого исполняемого файла (тогда cmake сам подставит путь вместо цели)
- `CONFIGURATIONS` -> список конфигураций, для которых будет запущен тест (в том числе в этом списке может быть указана пустая конфигураций - `""`). По умолчанию тест запускается для всех конфигураций
- `WORKING_DIRECTORY` -> директория (абсолютная), в которой будет запущен тест. По умолчанию - `CMAKE_CURRENT_BINARY_DIR`

>[!warning]
>Команда `add_test()` добавляет не тест-кейс или тест-сьют, а исполняемый файл с тестами - тестовое приложение.

___
### 1. Приложение CTest

Команда `ctest` без аргументов, выполненная в директории билда запустит все тестовые приложения.

Весь вывод тестов (stdout, stderr), как успешных так и нет можно посмотреть в логе. Путь к логу будет выведен на экран командой ctest после выполнения тестов:
- `${build}/Testing/Temporary/LastTest.log`

Опции:

`-С configname`
- запустить все тестовые приложения, у которых указано данное `configname`

`-V, -VV, -VVV`
- более подробный вывод

`--timeout`
- установить таймаут по умолчанию, который будет работать только для приложений у которых неустановлено свойство `TIMEOUT`

`-N`
- напечатать имена всех тестовых приложений

`-R regex`
- выполнить тестовые приложения, имена которых подходят под регулярное выражение
`-E regex`
- не выполнять тестовые приложения, имена которых подходят под регулярное выражение
___
### 2. Полезные свойства

Настраивать поведение тестов можно с помощью свойств исполняемых приложений.
set_tests_properties(fooWithoutBar PROPERTIES

`ENVIRONMENT "VAR1=value1;VAR2=value2"`
- установить определенное окружение для тестового приложения

`PASS_REGULAR_EXPRESSION regex_list`
`FAIL_REGULAR_EXPRESSION regex_list`
- определять результат теста на основе его стандартного вывода
- вывод может подходить под одно из этих условий или сразу под оба
- если вывод подходит под `FAIL`-условие, то тест будет провален (даже если `PASS`-условие тоже выполнено)
- если `PASS_REGULAR_EXPRESSION` установлено и непусто, то код выхода не учитывается

`SKIP_RETURN_CODE num`
- если это свойство установлено и тестовое приложение возвращает `num`, то результаты теста учитываться не будут

`DISABLED YES|NO`
- не учитывать результаты тестового приложения

`WILL_FAIL`
- инвертировать результат тестового приложения

`TIMEOUT t`
- указать таймаут в секундах. Если тестовое приложение не закончило свою работу зак указанное количество секунд, то оно будет принудительно завершено и отмечено как проваленное.
___
### 3. Зависимости тестовых приложений

В некоторых случаях удобно иметь зависимости между тестовыми приложениями.
Например:
- нужно запустить сервер
- запустить несколько тестов 
- остановить сервер

Можно установить зависимости между тестовыми приложениями:
```
set_tests_properties(test3 test4 PROPERTIES DEPENDS "test1;test2")
```
Такого рода зависимость гарантирует последовательно запуска тестовых приложений, но и только. Т.е. если `test2` зависит от теста `test1`, то он будет выполнен после `test1` даже если `test1` был провален.

Однако, в некоторых случаях нет смысла запускать тестовое приложение если его зависимость была провалена. Эту логику можно реализовать с помощью свойств:

`FIXTURES_SETUP fixture_list`
- список фичей, которые подготавливает (проверяет) данное тестовое приложение

`FIXTURES_REQUIRED fixture_list`
- список фичей, которые требуются данному тестовому приложению. Тестовое приложение будет запущено только в том случае, если все требуемые фичи были подготовлены. Фича считается подготовленной, если она указана в списке `FIXTURES_SETUP` какого-то другого тестового приложения и оно было успешно(!) выполнено.

`FIXTURES_CLEANUP fixture_list`
- список фичей, которые должны быть полностью использованы перед запуском этого приложения. Фича считается полностью использованной, если уже отработали все приложения у которых фича упомянута в списке `FIXTURES_REQUIRED` или `FIXTURES_SETUP` (не обязательно успешно)

Причем `SETUP` и `CLEANUP` приложения будут запущены автоматически, даже если они напрямую не указаны. Например:
```
add_test(NAME S)
add_test(NAME R)
add_test(NAME C)

set_tests_properties(R PROPERTIES DEPENDS "S")
set_tests_properties(C PROPERTIES DEPENDS "R")
set_tests_properties(C PROPERTIES DEPENDS "S")

set_tests_properties(S PROPERTIES FIXTURES_SETUP    A_feature)
set_tests_properties(R PROPERTIES FIXTURES_REQUIRED A_feature)
set_tests_properties(C PROPERTIES FIXTURES_CLEANUP  A_feature)
```

Если запустить `ctest -R "R"`, то будут выполнены все три приложения причем в нужном порядке: S -> R -> C.


