___
Генераторные выражения существуют в первую очередь для поддержки multi-конфигурационных генераторов.

Процесс сборки разных конфигураций описан в статье: [[cmake - build type]].
Если коротко:
- для single-конфигурационных генераторов тип билда определен уже на стадии конфигурирования
- для multi-конфигурационных генераторов тип билда определяется при вызове команды `cmake --build`

Генераторные выражения вычисляются во время выполнения команды `cmake --build`. (в single-конфигурационных генераторах вычисление происходит во время конфигурирования, но это не имеет значение в этом случае).

В целом для single-конфигурационных генераторов не нужны генераторные выражения. Однако, чтобы обеспечить кроссплатформенность рекомендуется во всех случаях использовать генераторные выражения для обработки логики связанной с типом билда.
___
### 1. Использование

Генераторное выражение имеет синтаксис `$<something>` и в результате вычисления преобразуется в строку. Генераторные выражения могут вычисляться рекурсивно.

Генераторные выражения вписываются непосредственно в команду следующим образом:
```
target_compile_definitions( app PUBLIC "$<IF:$<CONFIG:Debug>,Alice,Bob>" )
```

>[!warning]
>Не все команды поддерживают генератные выражения.
>Если команда поддерживается генераторное выражение, то это должно быть напрямую указано в референсе.

Генераторные выражения нужны для того, чтобы вычислить некоторую строку на основе информации, которая может быть получена только на момент билда. Поэтому все генераторные выражения можно разделить на два типа:
- направленные на получение информации
- реализующие условную логику

___
### 2. Получение информации

`$<CONFIG>`
- выычисляется в тип конфигурации (build-type)
`$<PLATFORM_ID>`
- выычисляется в идентификатор платформы, так же как переменная `CMAKE_SYSTEM_NAME`. 
`$<C_COMPILER_VERSION>`
`$<CXX_COMPILER_VERSION>`
- выычисляется в номер версии

`$<CONFIG:configname>`
- если текущий конфигурация равна `configname`, то вычисляется в `1`

`$<TARGET_PROPERTY:targetname,propertyname>`
`$<TARGET_PROPERTY:propertyname>`
- вычисляется в значение свойства `propertyname` для цели `targetname`
- если `targetname`, то для цели для которой генераторное выражение вычисляется (?)

`TARGET_FILE (абсолютный путь)`
`TARGET_FILE_NAME (basename)`
`TARGET_FILE_DIR (директория)`
- вычисляется в путь к файлу цели

`TARGET_OBJECTS`
- вычисляется в список объектов объектной библиотеки

___
### 3. Условная логика

`$<somestring:...>`
- если `somestring` вычисляется в `true`, то результатом вычисления будет `...` , в противном случае - пустая строка

`$<BOOL:...>`
- если `...` вычисляется в `true`, то результатом вычисления будет `1`, в противном случае - `0`.

`$<AND:expr[,expr...]>`
`$<OR:expr[,expr...]>`
`$<NOT:expr>`
- работают предсказуемо
- `expr` должен вычисляться только в `1` или `0`, в противном случае его стоит завернуть в `$<BOOL:...>` 

`$<IF:expr,val1,val0>`
- `expr` должен вычисляться только в `1` или `0`
- в остальном работает предсказуемо

`$<STREQUAL:string1,string2>`
`$<EQUAL:number1,number2>`
`$<VERSION_EQUAL:version1,version2>`
`$<VERSION_GREATER:version1,version2>`
`$<VERSION_LESS:version1,version2>`
- тестовые конструкции
- результатом всех этих конструкций может быть либо `1`, либо `0`

`$<LOWER_CASE:…>`
`$<UPPER_CASE:…>`
- конвертирование строки

___
### 4. Пример

Файл CMakeLists.txt:
```
cmake_minimum_required( VERSION 3.25 )
project( App LANGUAGES CXX )
add_executable( app main.cpp )
target_compile_definitions( app PUBLIC "$<IF:$<CONFIG:Debug>,Alice,Bob>" )
```

Создадим две папки билда и сгенерируем два набора проектных файлов:
```
cd build/Release
cmake -DCMAKE_BUILD_TYPE:STRING=Release ../
cd build/Debug
cmake -DCMAKE_BUILD_TYPE:STRING=Debug ../
```

Если перейти в директорию `${workdir}/build/Debug` и выполнить команду `make VERBOSE=1` то мы увидим строчку:
```
/usr/bin/c++ -DAlice -g...
```
Если выполнить ту же команду в директории `${workdir}/build/Release` то мы увидим:
```
/usr/bin/c++ -DBob -O3 -DNDEBUG...
```

