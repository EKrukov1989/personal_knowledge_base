___
ssh можно использовать для подписи и верификации файлов (и даже настоятельно рекомендуется).

>[!note]
>Сейчас существует возможность обмениваться ключами через github. Ключи любого пользователя находятся по адресу `https://github.com/USERNAME.keys`.

___
### 1. Подпись файлов

Подписать файл (или несколько файлов) можно с помощью одной команды:
```bash
ssh-keygen -Y sign -f sign_key -n asn filename1 filename2
```
где:
- `sign_key` -> ключ, которым будет производится подпись.
- `asn` -> additional signature namespace, описывает назначение сигнатуры. Есть три asn предложенных ssh (file, email, git), но можно использовать свои. Рекомендовано создавать пространства имен в форме `NAMESPACE@YOUR.DOMAIN`.
- `filename1` - путь к файлу, который следует подписать

>[!warning] Опция `-n` обязательна!

Как результат исполнения команды будут созданы файлы `.sig` в той же директории, в которой находились подписываемые файлы. Содержимое файлов примерно следующее:
```
-----BEGIN SSH SIGNATURE-----
<long_string_base64encoded>
-----END SSH SIGNATURE-----
```

Несмотря на то, что файл `.sig` человекочитаемый, никакой информации из него вытащить нельзя.

___
### 2. Верификация файлов

Чтобы верифицировать файл нужно:
- иметь файл
- иметь файл подписи
- знать additional signature namespace
- знать принципал, того кто подписал файл
- знать публичный ключ, которым был подписан файл

Верификация файлов также осуществляется с помощью ssh-keygen.
ssh-keygen помимо вышеперечисленного требует:
- `allowed_signers_file` -> список подписантов, заслуживающих доверия
- `revocation_file` -> список отозванных ключей (опционально)

`allowed_signers_file` имеет следующий вид:
```
alice@example.com ssh-ed25519 AAA...8O7
alice@example.com ssh-rsa AAA...c5j
bob@example.net ssh-ed25519 AAA...X5b
eve@example.org ssh-ed25519 AAA...dMG
```

Каждая строка этого файла должна содержать:
- принципалы
- опции (необязательно)
- тип ключа
- публичный ключ подписанта

Теперь можно проверить файл с помощью команды:
```bash
ssh-keygen -Y verify -f allowed_signers_file -I principal -n file -s file.sig [-r revocation_file] < file
```

>[!note]
>Так как при подписи файла принципал не используется, значит эта информация нужна только да поиска публичного ключа в allowed_signers

___
### 3. Пример

##### 3.1. Подпись

Есть файл `msg` в текущей директории который мы хотим подписать. Содержимое файла не имеет значения.

У нас есть пара ключей `~/.ssh/test_rsa` и `~/.ssh/test_rsa.pub`. Содержимое публичного ключа:
```
ssh-rsa AAA...S0= gene@aspire
```

Подписываем файл с помощью команды
```bash
ssh-keygen -Y sign -f ~/.ssh/test_rsa -n file msg
```
Получаем в текущей директории файл подписи `msg.sig`.

##### 3.2. Верификация

Создаем в текущей директории файл `allowed_signers`.
Добавляем туда содержимое `~/.ssh/test_rsa.pub`, только принципал должен быть в начале строки. Результат должен быть таким:
```
gene@aspire ssh-rsa AAA...S0=
```

Проверяем файл `msg` с помощью команды:
```bash
ssh-keygen -Y verify -f allowed_signers -I gene@aspire -n file \
-s msg.sig < msg
```

Результат должен быть следующим:
```
Good "file" signature for gene@aspire with RSA key SHA256:4kX...z4Y
```

___
### 4. Использование сертификата для подписи

Все в целом так же как и раньше, с небольшими изменениями.

У нас имеются файлы:
- `file_ca`, `file_ca.pub` -> ключи для подписи
- `msg` -> файл, который нужно подписать

Создаем сертификат подписанта:
```bash
ssh-keygen -s  file_ca -I file_ca -z 105 file_ca.pub
```

Подписываем файл созданным сертификатом:
```bash
ssh-keygen -Y sign -f file_ca-cert.pub -n file msg
```

Добавляем в `allowed_signers` следующую строку:
`file_ca <content_of_file_ca-cert.pub>`
где `file_ca` это key id подписанта

Проверяем файл:
```bash
ssh-keygen -Y verify -f allowed_signers -I file_ca -n file -s msg.sig < msg
```
