___
Политика - задукоментированное изменение в поведении cmake, которое было внесено в одной из версий. Каждой политике присвоен четырехзначный идентификатор и каждая политика обозначается как `CMPxxxx`.

Каждое версии cmake соответствует определенное состояние набора политик. Политики в этом наборе могут находится в одном из двух состояний - `NEW` или `OLD`. Состояние `NEW` означает что в этой версии данная политика применена и наоборот.

Можно настраивать поведение cmake посредством изменения версии или же посредством изменения отдельных политик.
___
### 1. Настройка с помощью версий

Основной способ настройки политик - с помощью версий.

При установке определенной версии все политики будут приведены в состояние, соответствующее данной версии. Для этого имеет две команды:
```
cmake_minimum_required(VERSION v)
```
- устанавливает минимально возможную версию cmake
- устанавливает все политики относительно выбранной версии cmake
```
cmake_policy(VERSION major[.minor[.patch[.tweak]]])
cmake_policy(VERSION <version_1>...<version2_>)
```
- только устанавливает все политики относительно выбранной версии cmake

>[!note]
>Мне не удалось найти переменную в cmake, которая отвечала бы за текущую версию. Полагаю это связано с тем, что политики в текущем состоянии необязательно должны точно соответствовать какой-либо из версий.
>Всего существует три типа переменных, которые характеризуют версии:
>- `CMAKE_VERSION` -> версия cmake, который сейчас установлен
>- `CMAKE_MINIMUM_REQUIRED_VERSION` -> минимальня версия cmake для проекта, которая установлена с помощью команды `cmake_minimum_required()`
>
>Еще есть `CMAKE_PROJECT_VERSION` -> но это версия проекта, а не cmake.

___
### 2. Изменение отдельных политик

Проверить включена определенная политика или нет можно с помощью следующей конструкции:
```
if (POLICY CMPxxxx)
...
```
Получить информацию о применении политики, либо применить политику можно следующим образом:
```
cmake_policy( SET CMPxxxx <NEW|OLD> )
cmake_policy( GET CMPxxxx outVar ) # outVar равно либо NEW либо OLD
```

___
### 3. Policy stack

В общем случае текущую политику cmake нельзя охарактеризовать только номером версии, ее следует рассматривать как набор переменных `CMPxxxx`.

В процессе работы cmake в памяти одновременно хранится сразу несколько таких наборов, которые организованы в стэк.

Все следующие команды взаимодействуют только с верхним набором в стэке:
- `cmake_minimum_required( VERSION ... )`
- `cmake_policy( VERSION ... )
- `cmake_policy( SET ... )`
- `cmake_policy( GET ... )`
- `POLICY CMPxxxx`

Однако существуют команды, которые позволяют взаимодействать со стэком:
```
cmake_policy(PUSH)
cmake_policy(POP)
```
- команда PUSH создает копию верхнего набора в стэке и вставляет его на вершину стэка
- команда POP удаляет верхний набор в стэке

Данные команды вызываются внутри команд `add_subdirectory()` и `include()`:
- перед началом чтения файла вызывается команда PUSH
- по окончании чтения файла вызывается команда POP

Таким образом любые изменения политик в субдиректории или включенном файле не могут повлиять на политики в вызывающем файле (если не указано `NO_POLICY_SCOPE`).

___
### 4. Временные изменения

Зачастую нужно внести временное изменение в набор политик, то можно выполнить это несколькими способами:
1. В лоб:
```
cmake_policy(SET tmp_value)
... you code
cmake_policy(SET former_value)
```
2. С помощью операций со стэком:
```
cmake_policy(PUSH)
cmake_policy(SET ...)
... you code
cmake_policy(POP)
```
2. С помощью block:
```
block(SCOPE_FOR POLICIES)
    cmake_policy(SET ...)
    ... you code
endblock() # политики будут возвращены в исходное состояние на выходе из блока 
```













