___
### Введение

Регулярное выражение - это выражение (строка), которое определяет некоторый набор строк (возможно бесконечного размера).

Движок (regex-engine) - программа, которая находит в тексте подстроки, которые соответствуют заданному регулярному выражению.

Флэйвор (flavor) - определенный синтаксис регулярных выражений.

В данной статье описан самый базовый синтаксис. Весь приведенный функционал есть почти в каждом флейворе, причем синтаксис во всех флэйворах будет примерно одинаковым.

>[!note]
>В синтаксисах BRE и ERE есть одно важное различие. В BRE метасимволы имеют особое значение, только если они экранированы обратным слэшем, а в ERE - наоборот. В этой статье все примеры приведены для ERE-синтаксиса.

___
### 1. Особенности поиска

##### Особенность 1:
- Регулярные выражения по умолчанию чувствительны к регистру

##### Особенность 2:
- Движок всегда возвращает только одну подстроку

Если поставить перед движком задачу найти все подходящие строки в тексте, то он будет проверять текст слева-направо пока не найдет одну подходящую строку, а потом запустит весь процесс заново, но уже в оставшейся части текста.
Поэтому мы можем считать, что движок всегда ищет только одну строку.

##### Особенность 3:
- Движок всегда находит самую левую подходящую подстроку

Самой левой строкой называется подстрока, первый символ которой имеет наименьший индекс. Все движки производят поиск слева направо и когда находят подходящую строку, которая полностью соответствует регулярному выражению, останавливают поиск и возвращают результат.

##### Особенность 4:
- Стандарт POSIX требует, чтобы движок находил самое длинное совпадение из возможных.

Если есть несколько подходящих строк, которые начинаются с одного индекса, то движок должен выбрать самую длинную.

>[!warning]
>Стандарт соблюдается далеко не всегда - многие движки не всегда возвращают самую длинную строку.

___
### 2. Простейшее регулярное выражение

Простейшее регулярное выражение - это набор обычных символов.
Например: `abc`. Такое выражение соответствует только такой же строке - `abc`.

___
### 3. Метасимвол-точка (dot)

Символ точка замещает один любой символ, кроме символов окончания строк (по умолчанию).
Например: `ab.` определяет следующий набор строк: `aba`, `abb`, `abc`, ... , `ab0`, `ab1` ...

---
### 4. Повторение (repetition)

Если в выражении за обычным символом расположен один из следующих метасимволов - `?` `*` `+`, то этот символ может быть повторен несколько раз. А именно:
`?` -> ноль или одно повторение
`*` -> ноль или несколько повторений
`+` -> одно или более повторений

Примеры:
```
abc? определяет: ab, abc
abc* определяет: ab, abc, abcc, abccc, ...
abc+ определяет:     abc, abcc, abccc, ...
```

Или же можно указать сколько именно раз нужно повторять символ с помощью конструкции `{}`. Примеры:
- `a{n}` -> повторить ровно `n` раз
- `a{min,max}` -> от `min` до `max` раз
- `a{min,}` -> не менее `min` раз

>[!warning]
>Нужно помнить, что все варианта повторения жадные (greedy) и находят соответствие максимальной длины.

___
### 5. Круглые скобки (round braces)

Если часть регулярного выражения взять в скобки, то можно применить повторения сразу к целому регулярному выражению внутри скобок. Например:
`a(bcd)* определяет: a, abcd, abcdbcd, abcdbcdbcd, ...`

___
### 6. Альтернэйшн (alternation)

Допустим, у нас есть два регулярных выражения и мы хотим найти подстроки в тексте, которые удовлетворяют хотя бы одному из этих выражений. В таком случае мы можем воспользоваться метасимволом `|` (вертикальная черта). Пример:
`cat|dog` -> найдет всех `cat` и `dog` в тексте.

Оператор альтернэйшна имеет наименьший приоритет в языке регулярных выражений. Поэтому все что находится между двумя операторами альтернэйшна - это одно регулярное выражение.

Однако оператор альтернейшна можно использовать и внутри другого регулярного выражения, если использовать скобки. Например:
`sound|col(o|ou)r` -> соответствует словам: `sound, color, colour`

>[!warning]
>В некоторых флэйворах порядок в альтернэйшн может иметь значение.

___
### 7. Набор символов (character classes)

Набор символов записывается в виде последовательности символов, заключенной в квадратные скобки, например: `[abc]`. Набор символов замещает ровно один символ и может замещать только символы, перечисленные в наборе.

Набор символов может быть указан в виде диапазона -> `[a-z]`, или же в виде последовательности диапазонов -> `[a-zA-Z]`. 

>[!note]
>Диапазоном называются два символа, разделенных дефисом.

Если в наборе символов сразу после первой открывающей квадратной скобки поставить символ `^`, то получится отрицающий набор символов (negated character classes). Например: `[^a-z]`

Отрицающий набор символов заменяет собой один и только один символ, но может замещать только символы, которые не перечислены в шаблоне.

>[!note]
>Отрицающий набор символов может замещать символы окончания строки. Т.е. `[^a-z]` может заместить символ `\n`.

>[!note]
>Если в отрицающем наборе перечислены несколько символов или диапазонов, то все они отрицающие.
>Пример: `[^a-zA-F0-9]` -> ни буква ни цифра

>[!tip]
>Набор символов воспринимается как единый элемент, поэтому если мы хотим использовать повторение для набора символов то нет смысла брать его в круглые скобки.

___
### 8. Якори начала и конца строки

Можно задать положение искомой строки в тексте с помощью якорей:
`^` -> якорь начала строки
`$` -> якорь конца строки
Пример: `^[0-9]+$` -> положительное целое число

По умолчанию якоря работают для каждой строки в тексте. Т.е. началом считается не начало текста, а начало каждой строки -> это начало текста, а также начало после каждого символа окончания строк. Для конца - аналогично.

>[!note]
>Выражение, которое содержит только якорь (`$` или `^`) соответствует только пустой строке.

___
### 9. Границы слов

Иногда очень удобно ограничить регулярное выражение в пределах слова.
Для этого используется пара метасимволов `\b`, например `\bregex\b`. Это означает что выражение `regex` должно заместить целое слово от начала до конца.

Словом называется непрерывная последовательность символов, которую можно выразить регулярным выражением `[_a-zA-Z0-9]+`.

Пример:
```
text: "system, systemd, systematically system notsystem system"
# regex "\bsystem\b" подойдет здесь для всех слов system
```

___
### 10. Специальные символы (metacharacters)

Теперь когда нормальный вид регулярных выражений понятен, можно поговорить о тонкостях, о метасимволах.

Метасимволы - это 12 символов, которые имеют особое значение: 
`\ ^ $ . | ? * + ( ) [ {`

>[!note]
>Одинарные и двойные кавычки (` " ' `) - не метасимволы.

Чтобы использовать метасимволы в их буквальном значении, нужно экранировать их с помощью обратного слэша.
Пример: `a\*` -> определяет подстроку `a*`

При этом важно отличать экранирование в регулярных выражениях, от других видов экранирования. Например:

```C++
// Мы хотим найти строку "с:\temp"
// Значит нам нужно регулярное выражение: "с:\\temp"
// То есть именно такую строку мы должны передать в regex-engine.
// В С++ такая строка записывается так:
std::string pattern = "c:\\\\temp";
```

>[!tip]
>По этой же причине в bash нужно экранировать кавычки. Например если у нас есть регулярное выражение `"q"`, то в grep мы должны записать его следующим образом: `grep "\"q"\"`. Но это запись для grep - регулярное выражение само по себе не требует экранирования кавычек.

___
### 11. Непечатные символы

Можно записать непечатный ASCII символ, если знать его код:
`\xA9` - так можно записать символ копирайта

`\R` - может заменять любой символ окончания строки: `\r`, `\n` и даже `\r\n`.

___
### 12. Метасимволы внутри наборов

В регулярных выражениях (с редкими исключениями) внутри набора символов только следующие символы считаются метасимволами: `]\^-`. 

Чтобы указать символы в буквальном значении внутри квадратных скобок, нужно придерживаться следующих правил:
- `\` -> нужно экранировать -> `\\`
- `^` -> в любом месте кроме начала -> `[x^]`
- `]` -> расположить в самом начале или после `^` -> `[]x]` -> `[^]x]`
- `-` -> в начале, в конце или после `^` -> `[-x]` -> `[x-]` -> `[^-x]`
- все остальные символы - не экранировать.

>[!note]
>Логика всех этих правила заключается в следующем:
>Метасимволы на таких позициях не могут выполнять свои специальные функции, а значит могут быть использованы только буквально.
