___
https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170

Символы может иметь `internal linkage` или `external linkage`.

`external linkage` - символ видим из любого юнита трансляции в программе.
`internal linkage` - символ видим только внутри юнита трансляции в котором он объявлен, поэтому одно и то же имя с `internal linkage` может существовать в нескольких юнитах трансляции

По умолчанию `external linkage` имеют:
- неконстантные глобальные переменные 
- свободные функции (функция, которая определена в глобальном пространстве имен или именованном пространстве имен)
По умолчанию `internal linkage` имеют:
- константные и constexpr переменные
- typedef
- static переменные

Объявление функции может быть отдельно отдельно от определения, поэтому рассматривать их бессымленно.

Объявление переменные одновременно является ее определение, поэтому объявлять переменную в заголовочном файле нельзя.

___
### 1. Сделать неконстантную переменную доступной извне

Файл `a.h`:
```cpp
#pragma once
extern int a;
```
Файл `a.cpp`:
```cpp
// здесь даже #include "a.h" необязателен
int a = 5; // неконстаная глобальная переменная
           // имеет external linkage по умолчанию
```
Теперь везде можно включать заголовочный файл `a.h`.

___
### 2. Сделать константную переменную доступной извне

Отличие заключается тольков том, что нужно добавить extern при объявлении.
Файл `a.h`:
```cpp
extern const int a;
```
Файл `a.cpp`:
```cpp
extern const int a = 5;
```

___
### 3. Сделать неконстантную переменную недоступной извне

Если объявить переменную как static, то она будет недоступна в любом случае:
Файл `a.cpp`:
```cpp
static int a = 5;
```
Файл `main.cpp`
```cpp
extern int a;
int main () {
	std::cout << a;  // ошибка! undefined reference
}
```





