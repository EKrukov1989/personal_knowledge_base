___

Команда `merge` внедряет все изменения из заданной ветки в текущую ветку.
Заданная ветки и текущая ветка должны ответвляться от одного коммита.

>[!warning]
>Перед началом мержа следует убедиться, что индекс пустой.
>Изменения в рабочем дереве можно оставить, если они не конфликтуют с вмерживаемыми изменениями.

Далее будут использоваться следующие обозначения:
`cur` -> текущая ветка, на которую указывает `HEAD`
`chosen` -> заданная ветка, которую следует вмержить в текущую

Предположим, что ветки выглядят следующим образом:
```text
      A---B---C chosen
	 /
D---E---F---G cur
```

`git merge `

Процесс мержа следующий:
- все изменения в `chosen`-ветке с момента разветвления применяются к последнему коммиту в `cur`-ветке
- если изменения применены успешно, то создается новый коммит в `cur`-ветке и `HEAD` продвигается вперед

```text
      A---B---C chosen
	 /         \
D---E---F---G---H cur
```

Если в обеих ветках содержаться изменения в одних и тех же файлах и эти изменения нельзя согласовать, то процесс мержа останавливается и пользователю предлагается разрешить конфликты вручную.

___
### 1. Мерж-коммит

В результате мержа создается не обычный коммит, а мерж-коммит.
Он отличается тем, что содержит несколько родителей.
Пример мерж-коммита:
```
tree 7f45e7c1ddbed8c8349bf7347e0c98eb9c133335
parent 408b0fdde575e1034a33be0ba820d18f8553cdd5
parent dcc6790b1f535901b0f5d0a15aa8865ad75490d0
author Gene Kryukov <evgenykryukov@mail.ru> 1692031961 +0300
committer Gene Kryukov <evgenykryukov@mail.ru> 1692031961 +0300

<commit_message>
```

___
### 2. Виды мержей

2.1. UP TO DATE

Если выясняется, что заданная ветка является предком текущей, то мердж отменяется и выводится сообщение: `Already up to date.`

2.2. FAST-FORWARD MERGE

Если текущая ветка является предком заданной, то `HEAD` перемещается вперед до до коммита, на который указывает `chosen`-ветка. 
Больше никаких действий не требуется, это называется fast-forward merge.

2.3. TRUE MERGE

Если две ветки имеют общего предка и несколько коммитов поверх этого предка, то действительно требуется мерж.

___
### 3.  Разрешение конфликтов

В случае возникновения конфликтов git выводит следующее сообщение:
```
Automatic merge failed; fix conflicts and then commit the result.
```

Коммит не создается, `HEAD` остается на прежнем месте.
В этом момент репозиторий все еще находится в состоянии мержа, хотя пользователь уже снова может вводить команды.

В индексе для каждого конфликтного файла создано по три файла:
1. Общий предок
2. Версия HEAD
3. Версия MERGE_HEAD

Посмотреть конфликтные файлы в индексе можно с помощью команды:
- `git ls-files -u`
- `git ls-files --unmerged`

В рабочем дереве каждый конфликтный файл теперь находится в специальном состоянии. Теперь на месте каждого конфликтного фрагмента врезана следующая конструкция:
```
<common part>
<<<<<<< HEAD
<version from HEAD>
||||||| <hash-code of common ancestor>
<version from common ancestor>
=======
<version from chosen branch>
>>>>>>> <chosen branch name>
<common part>
```

С помощью команды `git status` можно определить какие файлы содержат конфликты. Такие файлы имеют статус-код `UU`. С помощью команды `git diff` можно вывести на экран список всех конфликтов.

Выйти из состояния мержа и вернуть все назад можно с помощью команды:
`git merge --abort`

Чтобы разрешить конфликт нужно:
- вручную исправить все конфликтные файлы (привести их в то состояние, которое мы хотим видеть в результате мержа)
- добавить конфликтные файлы с помощью команды `git add`
- выполнить команду `git merge --continue` или `git commit`

>[!note]
>После того как пользователь добавил файл с помощью `git add` , git считает все конфликты в файле разрешенными.

По умолчанию в конфликтных файлах указывается только две версии из веток, а версия общего предка не выводится. Чтобы выводить три версии, нужно установить переменную в конфиге: `git config --global merge.conflictStyle diff3`

Вместо разрешения конфликтов вручную можно вызвать мержтул с помощью команды: `git mergetool`. В результате будет вызван mergetool по умолчанию или же тот, что прописан в переменной кофига `merge.tool`.

___
### 4. Опции и команды

`--abort`
- отменить процесс разрешения конфликтов и попробовать вернуть все в прежнее состояние

`--quit`
- отменить процесс разрешения конфликтов, но оставить все как есть

`--continue`
- проверить что все конфликты разрешены
- сделать мерж-коммит
- переместить `HEAD` вперед

`-m`
- заранее указать сообщение к коммиту

`--no-commit`
- выполнить мерж, положить результаты мержа в индекс, но не выполнять коммит. Это позволяет пользователю предварительно проверить результаты мержа и уже самому закоммитить.

`--squash`
- выполнить мерж, положить результаты мержа в индекс, но не выполнять коммит, а также не делать запись `GIT_DIR/MERGE_HEAD`
- В результате этого можно вмержить изменения, но следующий коммит не будет мерж коммитом и будет иметь одного предка
