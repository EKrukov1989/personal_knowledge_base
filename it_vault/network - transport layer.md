### Введение

Коротко говоря, сетевой уровень предоставляет сервис пересылки пакетов внутри всей глобальной сети.

Однако, сетевой уровень не гарантирует, что пакет достигнет пункта назначения, также на сетевом уровне не требуется какого-либо подтверждения о том, что пакет был получен.

В то же время на прикладном уровне, мы уже хотим иметь надежный сервис, т.е. сервис, который будет надежно передавать запросы и получать ответы.

Кроме того, на прикладном уровне мы хотим отправлять запрос из приложения и получать ответ в приложении. На хосте может единомоментно работать несколько приложений, поэтому для адресации уже недостаточно IP-адреса, вводится новое понятие - порт.

Итого, на транспортном уровне решаются две проблемы:
- обеспечение надежности соединения
- мультиплексирование/демультиплексирование

Надежность соединений обеспечивается с помощью протокола TCP, а чтобы прикладные протоколы могли пересылать пакеты, не нарушая системы мультиплексирования - был создан протокол UDP.

## 1. Порты и сокеты

Каждый порт имеет номер-идентификатор, от 0 до 65 535.
- Порты в диапазоне \[0; 1 023\] называются well-known. Эти порты используются популярными приложениями.
- Порты в диапазоне \[49 152; 65 535\] называются динамическими. Их использует операционная система.
- К остальным портам пользователь может подключать свои приложения.

>[!note]
>TCP и UDP порты существуют независимо, т.е. могут одновременно работать TCP и UCP-порты c одинаковыми номерами.

>[!note]
>Кроме того, номера портов должны быть уникальны только для одного IP-адреса. Есть есть несколько интерфейсов, или есть несколько IP-адресов у одного интерфейса, то у каждого будет свой набор портов.

Итого прикладной процесс в сети однозначно характеризуется тремя параметрами:
- IP-адрес (принадлежащий интерфейсу этого хоста)
- тип протокола (транспортного уровня)
- номер порта
Пример: ( 192.168.213.100 + TCP + 2000 )

Пара ( IP-адрес + номер порта ) называется сокетом.
Сокеты бывают разных типов в зависимости от протокала: UDP-сокеты и TCP-сокеты.

## 2. Протокол UDP

Протокол UDP добавляет к IP только функцию мультиплексирования. 
Т.е. с помощью UDP можно передать пакет не на определенный IP, а на определенный порт.

Заголовок протокола UDP, содержит всего 8 байт и состоит из:
- номер UDP-порта отправителя
- номер UDP-порта получателя
- контрольная сумма
- длина дейтаграммы

## 3. Протокол TCP

Протокол TCP обеспечивает гарантированную доставку данных и основан на логическом соединении между двумя портами.

Каждый TCP-порт имеет две очереди: для входного потока данных и для выходного потока данных, которые накапливают в себе данных.

Данные в TCP пересылаются сегментами. Из выходной очереди вырезается непрерывная последовательность байтов и отправляется адресату. Такая последовательно называется сегмент.

>[!note]
>Сегмент это наиболее точный термин, но также применяется TCP-packet и TCP protocol data unit (PDU)

#### 3.1. Формат заголовков TCP

Подробно рассматривать все заголовки нет смысла, рассмотрим только значимые с точки зрения повествования.

![[tcp_headers.png]]

- Sequence number - число, которое отражает положение данного сегмента в общий последовательности переданных данных. Изначально, при установлении сессии (то есть установлен флаг SYN), генерируется некоторый случайный sequence number, который будет начальной точкой отсчета. В последующих пакетах sequence number будет увеличиваться по мере передачи данных.

- Acknowledgment Number - содержит порядковый номер октета, который отправитель желает получить (только если установлен флаг ACK).

Интересные управляющие биты:
- `ACK` -> поле acknowledgment number задействовано
- `PSH` -> запрос на отправку сообщения без ожидания заполнения буфера
- `RST` -> оборвать соединения, сбросить буфер ()
- `SYN` -> синхронизировать sequence numbers (при установлении соединения)
- `FIN` -> признак достижения передающей стороной последнего байта в потока передаваемых данных

#### 3.2. Установление соединения

Протокол TCP устанавливает логическое соединение между прикладными процессами. Причем в соединении может участвовать только два процесса.

>[!note]
>Такое соединение называется логическим, потому что о соединении знают только конечные хосты и только на транспортном уровне и выше. Маршрутизаторы не подозревают об этом соединении.
>

TCP-соединение является дуплексным, т.е. каждый из участников может одновременно отправлять и получать данные.

Соединение устанавливается по инициативе клиентской части соединения. Т.е. в соединение участвует двое и только двое: клиент и сервер.

Для установления соединения клиент посылает сегмент запрос на установление соединения. В запросе установлен только флаг SYN, а также указана следующая информация:

`flags = SYN`
`sequence number = 566 575 393` (например)
`acknowledgment number = 0` ( для этого сегмента всегда 0 )
`maximum segment size = 1460 bytes` (например)
`window size = 64 240`

Получив запрос, модуль TCP на стороне сервера пытается создать инфраструктуру для обслуживания нового клинта. Создает буферы, таймеры, счетики.

Если удалось все это создать, то сервер в ответ отправляет сегмент с флагом ACK и переходит в состояние установленного логического соединения. Ответны сегменты содержит следующую информацию:

 `flags = ACK, SYN`
`sequence number = 1 125 528 604` (например)
`acknowledgement number = 566 575 394`  (число не случайное)
`maximum segment size = 1460 bytes` ( ?? ?)
`window size = 65 160`

>[!warning]
>Сокет может одновременно участвовать в нескольких соединениях.

Допустим, сервер имеет TCP-сокет (IP1, p1). С этим сервером одновременно могут установить соединения несколько клиентов (IP2, p2), (IP3, p3).

Тогда с сокетом (IP1, p1) будет связано по два соединения, каждое из которых будет иметь свои буферы, счетчики, таймеры и так далее.

>[!note] 
>Соединение характеризуется парой сокетов.

#### 3.3. Метод скользящего окна

Клиент и сервер обмениваются друг с другому данными. В любой момент времени клиенту нужно передать серверу какие-то данные и в то же самое время наоборот - сервер тоже хочет передать какие-то данные клиенту.

Представим весь объем полезных данных, которую клиент передает серверу в виде непрерывной последовательности байтов.

Клиент передает эти данные в виде небольших непрерывных кусков данных - сегментов, причем некоторые сегменты могут быть потеряны.

С каждым сегментом клиент отправляет `sequence number` - который означает положение первого байта этого сегмента в общей последовательности (+ некоторая константа).  С помощью sequence number получатель соединяет полученные сегменты и может определить, если какой-то сегмент был утерян.

Вместе с ответным сегментом получатель отправляет `acknowlegdement number` - число, на единицу превышающее максимальный номер в полученном сегменте.

Таким образом отправитель узнает, какую часть информации уже дошла до получателя и может принять решение: отправлять следующий сегмент, или же выслать повторно предыдущий.

>[!note]
>Передача данных идет в дуплексном режиме. Поэтому в соединении всегда существует две пары `sequence number` и две пары `acknowledgment number`.

