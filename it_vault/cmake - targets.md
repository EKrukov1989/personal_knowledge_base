___
В данной статье рассмотрены вопросы добавления разнообразных целей.

Статья основана на двух главах и книги Craig Scott - Professional Cmake:
- Chapter 4. Building Simple Targets
- Chapter 16. Target Types

Цель (target) это некоторая именованная задача. В первую очередь под целью понимается задача сборки исполняемого файл, библиотеки или любая другая задача результатом которой будет файл.

Однако, зачастую в качестве цели удобно обозначить уже существующие файлы, которые не нужно собирать. Такие цели называются `IMPORTED`.

Далее подробно рассмотрены разные типы целей и процесс из добавления.
___
### 1. Новый executable

```cmake
add_executable(targetName [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL]
               source1 [source2 ...]
)
```
- создает цель создания исполняемого файла
- имя итогового исполняемого файла будет выбрано в соответствии с указанным `targetName`, но не обязательно должно быть точно таким же. Имя `targetName` нужно в первую очередь для того, чтобы можно было ссылаться на эту цель внутри `CMakeLists.txt`
- `EXCLUDE_FROM_ALL` -> исключить из списка целей по умолчанию

___
### 2. Новая library

```cmake
add_library(targetName [STATIC | SHARED | MODULE]
			[EXCLUDE_FROM_ALL]
			source1 [source2 ...]
)
```
- cоздает цель создания библиотеки
- `STATIC | SHARED` -> выбрать статическую или динамическую библиотеку
- `MODULE` -> динамическая библиотека, которая будет подгружена в runtime
- если тип библиотеки не указан, то он будет определен в соответствии с переменной `BUILD_SHARED_LIBS`.

___
### 3. Импортный executable и library

Если у нас уже имеет исполняемый файл или библиотека (что более вероятно), то можно добавить их в проект в виде целей:
```
add_executable(targetName IMPORTED [GLOBAL])
add_library(targetName (STATIC | SHARED | MODULE | OBJECT | UNKNOWN)
	IMPORTED [GLOBAL])
```
После добавления импортированный целей нужно обязательно указать путь к существующему файлу - присвоить этот путь для одного из следующих свойств:
- `IMPORTED_LOCATION`
- `IMPORTED_LOCATION_<CONFIG>`
Для cmake более приоритетным является свойства `IMPORTED_LOCATION_<CONFIG>`. Если это свойство неустановлено, то будет использовано значение из `IMPORTED_LOCATION`.

>[!note]
>Для Windows еще нужно `IMPORTED_IMPLIB`.

Если установить флаг `GLOBAL`, то импортированная цель будет иметь глобальную область видимости. По умолчанию импортированная цель видима только в области видимости текущей директории.

Так как для линковки достаточно пути к файлу, то в качестве типа библиотеки можно указать `UNKNOWN`.

Пример импортной shared library: [[cmake - targets examples]]
___
### 4. Псевдоним для executable

Можно создать псевдоним для цели:
```
add_executable(aliasName ALIAS targetName)
```
- нельзя создать алиас для алиаса
- можно создать алиас для импортированной цели, но только если она имеет глобальную область видимости
___
### 5. Новая object-library

>[!tip]
>Объектные библиотеки - экстремальная вещь, которая может помочь выиграть немножко времени компиляции. В большинстве случаев нужно отдать предпочтение обычным статическим библиотекам.

Создать объектную библиотеку можно следующим образом:
```
add_library(objLib OBJECT src1.cpp src2.cpp)
```
В реальности никакой библиотеки создано не будет, чтобы использовать сгенерированные объектные файлы нужно воспользоваться генераторным выражением:
```
add_executable(app1 app1.cpp $<TARGET_OBJECTS:objLib>)
```
___
### 6. Импортная object-library

Если уже имеется несколько объектных файлов, то их можно оформить как объектную библиотеку следующим образом:
```
add_library(targetName OBJECT IMPORTED [GLOBAL])
```
Для объектной библиотеки не нужны свойства `IMPORTED_LOCATION` и `IMPORTED_LOCATION_<CONFIG>`, однако нужно свойство `IMPORTED_OBJECTS`, которое должно содержать список объектных файлов.

Объектная библиотека может быть использована в `target_link_libraries()` в любом качестве.
___
### 7. Header-only library

Можно оформить header-only бибиотеку как цель с помощью команды:
```
add_library(targetName INTERFACE IMPORTED [GLOBAL])
```
Чтобы присвоить значения свойства такой цели нужно использовать слово `INTERFACE`:
```
target_include_directories(targetName INTERFACE ...)
target_compile_definitions(targetName INTERFACE ...)
```

Пример: [[cmake - targets examples]]
___
### 8. Объединение библиотек

Можно создать фейковую библиотеку, которая буде представлять собой набор библиотек (но без создания самого файла библиотеки, конечно):
```
add_library(targetName INTERFACE)

target_link_libraries(targetName INTERFACE
	lib1
	lib2
	...
)
```
Теперь если прилинковать цель к `targetName`, то она будет прилинкована ко всем перечисленным выше либам.
```
target_link_libraries(myApp PRIVATE targetName)
```
