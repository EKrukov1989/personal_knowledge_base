___
В cmake есть несколько видов переменных, к сожалению.
___
### 1. Нормальные переменные

Синтаксис:
```
set(varname value)  # установить значение переменной
unset(varname)      # сделать неустановленной
set(varname)        # то же сделать неустановленной
${varname}          # разыменовать переменную
DEFINED varname     # проверить, что значение переменной установлено
```
Замечания:
- Переменные в cmake это просто строки.
- Даже список это просто строка, в которой элементы разделены точками с запятой.
- Переменные действуют только внутри своей области видимости. Вне этой области видимости не могут быть прочитаны или записаны.
- Если переменная уже установлена, то следующая команда set просто переопределит ее значение
- Если разыменовать неустановленную переменную, то результатом будет пустая строка
- Cmake может разыменовывать переменные рекурсивно, например:
```
${final_${varname}}
```
- Переменная может представлять список. Список в cmake это такая же строковая переменная, которая хранит элементы разделенные точками с запятой. Можно задать список следующими способами:
```cmake
set(arr abc def ghi)
set(arr abc;def;ghi)
```

При разыменовании списка нужно помнить, что:
```
set(arr a b c)
message(STATUS ${arr}   ) # output: abc
message(STATUS "${arr}" ) # output: a;b;c
```
___
### 2. Переменные окружения

В cmake можно устанавливать и использовать переменные окружения.
Памятка по синтаксису:
```
set( ENV{varname} value )
unset( ENV{varname} )
set( ENV{varname} )
$ENV{varname}
DEFINED ENV{varname}
```
Установленные таким образом переменные окружения будут действовать только до конца текущего процесса cmake, то есть в процессе configuring & generation.

Сборка будет происходить в новом процессе, поэтому сделанные таким образом изменения переменных окружения не сохраняться.
___
### 3. Кэш-переменные

Памятка по синтаксису:
```
set(varname value CACHE type "docstring" [FORCE])
option(var docstring [val]) # то же что set(var val CACHE BOOL docstring)
unset( varname CACHE )
set( varname CACHE )  # так нельзя!
$CACHE{varname}
${varname}  # если нет нормальной переменной с именем varname
DEFINED CACHE{varname}
```

При каждом использовании функции set обязательно указывается номинальный тип кэш-переменной и docstring.

Тип кэш-переменной нужен только для правильного отображения это переменной в CMakeGUI или ccmake. Типы могут быть следующие:
- `BOOL` -> логический тип (`ON/OFF, TRUE/FALSE, 1/0`)
- `FILEPATH` -> путь к файлу
- `PATH` -> путь к директории
- `STRING` -> строка
- `INTERNAL` -> переменная, которая не будет показана пользователю

Docstring - это строка, которая поясняет назначение переменной. Эта строка также требуется для отображения.

Тип указывать обязательно, но он нужно только для удобства работы с Cmake GUI
##### Замечания:
- Если установить кэш-переменную то она сохраняется в CMakeCache.txt. В следующий раз при попытке установить с помощью команды set - ничего не произойдет. Если указать `FORCE`, то команда set будет изменить переменную в любом случае.
- Единовременно могут существовать нормальная переменная и кэш-переменная с одинаковыми именами.
- При установке кэш-переменной с помощью команды set, если существует нормальная переменная с таким же именем в этой же области видимости, то она будет удалена.
- При разыменовании `${varname}` если существует нормальная переменная с именем `varname`, то будет получено ее значение. Но если нормально переменной с таким именем не существует и существует кэш-переменная, то будет получено ее значение.
- Кэш-переменные можно устанавливать и удалять с помощью опции командной строки. Установленное таким образом значение переменной будет сохранена в кэше при запуске команды (однако это не означает, что такое значение не может быть переопределено последующими командами в `CMakelists.txt`).
```
cmake -D myVar:type=someValue ...  # установить кэш-переменную
cmake -U myVar  # удалить кэш-переменную
```

___
### 4. Области видимости

При включении файла с помощью `add_subdirectory()` он получает получает копию всех переменных, видимых в вызывающем `CMakeLists.txt` так же как в bash. Это значит:
- все переменные вызывающего файла будут видны в вызванном файле
- все новые переменные и изменения в существующих переменных не будут видны в вызывающем файле

>[!warning]
>При включении файла с помощью `include()` он будет находится в той же области видимости, что и вызывающий файл.

Так же Cmake предоставляет механизм для изменения переменных в области видимости родительского файла:
```
set(myVar bar PARENT_SCOPE)
```
- будет изменена переменная в родительской области видимости, при этом в текущей области видимости переменная не изменится!


