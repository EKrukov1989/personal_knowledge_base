___
В этой статье я кратко рассмотрю самые необходимые опции компилятора gcc применительно к компиляции программ на языке c++.
___
### 1. Синтаксис

>[!note]
>Для компиляции с++ файлов следует использовать не gcc, а g++, так как это дает дополнилнительные преимущества:
>- автоматически указывает линковку с c++ библиотекой
>- воспринимает `.c .h .i`-файлы как c++-файлы

Общий синтаксис: `g++ [options] [-o outfile] infile...`

С помощью такого рода команды можно из исходных файлов (`infile`) создать новый файл с именем `outfile`. Если не указать опцию `-o`, то результат будет выведен в стандартный вывод.
___
### 2. Стадии компиляции

Компиляция включать в себя четыре стадии:
- preprocessing
- compilation proper (собственно компиляция)
- assembly
- linking

Каждая стадия компиляция превращает исходный файл (или файлы) в файлы другого типа.
В c++ используются файлы следующих типов:

суффиксы|описание
-|-
`.h .hpp`|header-файл, который следует по умолчанию превратить в precompiled header
`.cpp .cxx`|файл исходного кода
`.ii`|исходный код, который уже прошел стадию препроцессирования
`.s`|код ассемблера
`.o, .obj, .a`|файл, который следует передать линкеру (на самом деле все файлы, не подходящие под паттерны)
`executable`|обычно файл, который мы хотим получить как конечный результат

>[!warning] gcc понимает тип файла исходя из его имени (а именно суффикса)!

Если выполнить команду без опций `[E|S|c]`, то будет создан executable с именем `app`:
```bash
g++ -o app main.cpp
```

С помощью опций `[E|S|c]` можно остановить работу компилятора на любой из стадий:
```bash
g++ -E -o main.ii main.cpp  # только препроцессировать
g++ -S -o main.s main.ii    # скомпилировать и выдать код ассемблера
g++ -c -o main.o main.s     # скомпилировать и выдать уже машинный код
g++    -o app main.cpp      # cлинковать в исполняемый файл
```

___
### 3. Debug

Существует несколько уровней дебага -> от 0..3, где уровень 0 соответствует отсутствию дебажной информации.

Дебаг по умолчанию включен. Если указать опцию `-g`, то будет установлен уровень дебага по умолчанию -> 2, такой же как и без этой опции. Поэтому указавать эту опцию без указания уровня - бессмысленно.

`-g<level=0..3>`
- указать уровень дебага

Отладочная информация будет интегрирована в конечный файл.
Вырезать отладочные символы можно с помощтю команды `strip`:
```bash
strip exec –o stripped_exec
```
___
### 4.  Оптимизация

Оптимизация позволяет скомпилировать более быстрый код и возможно более компактный код. Однако оптимизация обычно подразумевает увеличение времени на компиляцию.

Кроме того, без оптимизации отладка становится боле удобной.

`-O<level>`
- указать уровень оптимизации от 0 до 3

`без -O или -O0`
- компилятор выполняет только быстрые оптимизации

`-Og`
- уровень оптимизации удобный для дебага
- наилучший вариант в процессе разработки
___
### 5. Прекомпиляция заголовков

Можно предкомпилировать заголовочный файл заранее, а затем использовать предкомпилированный файл. Это позволит уменить время компиляции, зачастую - весьма значительно.

Если компилятор видит в исходном коде директиву `#include "name.h"`, то он ищет сначала файл с именем `name.h.gch` и если находит - то включает именно его.

>[!note]
>Важно, чтобы компилятор нашел `.gch`-файл. Можно либо положить его в ту же папку, что и соответствующий header-файл, что неудобно или включить в пути поиска с помощью опции `-I`.

Пример make:
```makefile
app : main.cpp pch.h.gch
	g++ -o app main.cpp

pch.h.gch : pch.h
	g++ -o pch.h.gch pch.h
```
main.cpp:
```C++
include <pch.h>
int main()
...
```
pch.h:
```C++
include <string>
include <vector>
...
```

___
### 6. Поиск header-файлов

Если компилятор находит в исходном файле директиву `#include`, то он проводит поиск header-файла и затем включает его содержимое в исходный файл. Компилятор выполняет поиск файл в некоторых стандартных директориях, а также в директориях, пути к которым явно указаны в командной строке с помощью опций: `-I <dir>`, `-iquote <dir>`, `-isystem <dir>`, `-idirafter <dir>`.

Есть две формы директивы `#include`:
- `#include <filename.h>` -> system-форма
- `#include "filename.h"` -> quoted-форма

Порядок поиска header-файлов следующий для quoted-формы:
1. `(только для quoted-формы)` директория текущего файла
2. `(только для quoted-формы)` директории добавленные с помощью опции `-iquote`
3. директории, добавленные с помощью опции `-I`
4. директории, добавленные с помощью опции `-isystem`
5. стандартные системные директории 
6. директории, добавленные с помощью опции `-idirafter`
   
Все директории, указанные с помощью опции одного типа, используются в порядке, в котором они указаны в командной строке.

>[!tip]
>Следовательно для стандартных библиотек лучше использовать system-форму, хотя в любом случае они будут найдены. Для своих файлов - только quoted-форму.

___
### 6. Linking

Объектные файлы имеют обычно суффикс `.o` или `.obj`, однако gcc не делает выводов о типе файла на основе таких суффиксов. gcc считает что любой файл без определенных суффиксов (`.h .cpp, .ii .s` и др.) подходит для линковки. Объектные файлы от файлов библиотек gcc отличает по содержимому, а не по суффиксам.

Для линковки следует использовать опции: `-l<name>` и `-L<libdir>`.

С помощью опции `-l<name>` можно дать указание линкеру прилинковать библиотеку с именем `lib<name>.a` или `lib<name>.so`. Если найдены оба файла то предпочтение отдается динамической библиотеке. Поиск библиотеки производится в нескольких стандартных директориях, а также в директориях, которые указаны с помощью опции `-L`.

Чтобы явно указать что нужно линковать только статические библиотеки следует использовать опцию `-static`.

Порядок в котором библиотеки и объектные файлы указаны в команде имеет значение. Допустим указаны следующие файлы: `foo.o -lbar baz.o`. В таком случае gcc загрузит из `libbar.a` только те функции, которые использованы в `foo.o`, но не в `baz.o`.

>[!warning] АХТУНГ! АХТУНГ!
>Порядок в котором указаны исходные файлы, объектные файлы, библиотеки, пути к бибиолтеками - имеет значение! 

Например:
```bash
g++ -o app main.cpp -lutils -L/a/b/c
```
- линковка будет успешной если в директории `/a/b/c` есть библиотека `libutils.a` или `libutils.so`.
- подразумевается, что в `main.cpp` есть директива `include "utils.h"`

>[!note] 
> Если имеется цепочка статических библиотек, то самую нижнюю в этой цепочке нужно линковать ко всем вышестоящим, вплоть до первого исполняемого файла или разделяемой библиотеки. Примеры:
> - `EXEC A` -> `STATIC B` -> ` STATIC C` - к B нужно прилинковать С, а к A нужно прилинковать B и C.
> - `EXEC A` -> `SHARED B` -> ` STATIC C` - к B нужно прилинковать С, а к A нужно прилинковать B.

___
### 7. Создание библиотек

Создать статическую бибиотеку `<name>` можно с помощью архиватора `ar`:
```bash
gcc -c -o file_1.o file_1.cpp
gcc -c -o file_2.o file_2.cpp
ar rcs lib<name>.a file_1.o file_2.o
```
 значение опций `rcs` следующее:
- `r` -> вставить элемент в архив, если элемент с таким именем существует - заменить
- `c` -> создать архив, если не существует
- `s` -> добавить индекс в архив или обновить его, если уже существует

Создать динамическую бибиотеку `<name>` можно с помощью `g++`:
```bash
gcc -c -fpic -o utils_1.o utils_1.cpp
gcc -c -fpic -o utils_2.o utils_2.cpp
gcc -shared -o lib<name>.so utils_1.o utils_2.o
```
Опция `-fpic` позволяет сгенерировать position independent code пригодный для использования в динамической библиотеке. Опция `-fPIC` дает такой же эффект, но не имеет ограничений по размеру global offset table (на x64 вряд ли пригодится).
___
### 8. Другие опции

`-std=[c++11|c++17|c++20...]`
- указать версию стандарта языка C++

`-x language`
- указать язык программирования на котором написаны исходные файл, это позволит компилятору правильно интерпретировать суффиксы
- например: `c, c++`
