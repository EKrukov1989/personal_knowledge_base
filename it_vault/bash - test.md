команда test проверяет типы файлов, а также сравнивает значения.

>[!warning] Команда test выходит со статусом, определенным выражением

Синтаксис:
`test [OPTIONS][EXPRESSION]`
или `[[OPTIONS] EXPRESSION]`


___
### 1. File tests

опция | описание | пример
-|-|-
`-e`, `-a`|наличие файла|`test -e <filepath>`
`-f`|обычный файл|
`-h`, `-L`|символьная ссылка|
`-d`|директория|
`-r`, `-w`, `-x`|наличие прав|`[ -x <filepath> ]`

>[!tip]
>При использовании `[]`, всегда нужно ставить пробелы после первой скобки и передд последней. Пример: `[ -x <filepath> ]`


___
### 2. Integer tests

опция|аналог|описание|пример
-|-|-|-
`-eq`|`(==)`|equality|`[ 2 -eq 1 ]` -> false
`-ne`|`(!=)`|inequality|`test 2 -ne 1` -> true
`-gt`|`(>)`|greater than|
`-lt`|`(<)`|less than|
`-ge`|`(>=)`|greator or equal|
`-le`|`(<=)`|less or equal|


___
### 3. String tests

обозначение|описание|пример
-|-|-
`=`, `==`|equality|`[ abc = def ]` -> false
`!=`|inequality|`test abc != bdef` -> true
`\<`|less than|`test 2 /< 1` -> false
`\>`|greater than|
`-z`|empty|
`-n`|nonempty| (не использовать! поведение непонятно)


>[!tip]
>При использовании строковых переменных нужно брать их в кавычки.
>На случай, если в строка окажуться пробелы. Пример:
>`str1=ab cd`
>`str2=def`
>`test $str1 \< $str2` -> `bash: test: <: unary operator expected`
>Правильно: `test "$str1" \< "$str2"`


___
### 4. Test own AND & OR features

Можно комбинировать условия внутри одного вызова команды test с помощью операторов `-a` (AND) и `-o` (OR):
`test 1 -eq 1 -a 2 -eq 2` -> 0 (true)
`test 1 -eq 1 -a 2 -eq 1` -> 1 (false)


___
### 5.  Construction `[[...]]`

>[!warning] Конструкция нестандартная и лучше использовать test

Данная конструкция:
- имеет такой же синтаксис как и test
- параметры так же разворачиваются
Однако:
- разделение слов не выполняется
- разворачивание имен файлов не выполняется

Важное достоинство этой команды -> оператор `=~`
С помощью этого оператора можно проверять соответствие расширенному регулярного выражению. Например:
`[[ whatever =~ h[aeiou] ]]` -> true

Таким образом можно в том числе определить, является ли одна строка частью другой строки.

___
### 6.  Construction `((...))`

>[!warning] Конструкция нестандартная и лучше использовать test

Данная конструкция позволяет вычислять арифметические выражения внутри себя. Например: `(( 2 + 3 ))` -> $? == 0

Если арифметическое выражение внутри скобок равно 0, то оно разворачивается в 1, то есть в false. И наоборот.

Если нужнр сравнивать целые числа и особенно результаты арифметических выражений, то такая такой вариант наиболее предпочтителен:
```bash
if $(( 1 + 1 == 2 ))
```
Для сравнения:
```bash
if test $(( 1 + 1 )) -eq 2
```


___
### 7. Negation

Можно инвертировать результат выражения с помощью оператора  `!` :
Можно использовать этот оператор как внутри квадратных скобок, так и снаружи:
```bash
if ! [ -e file.txt -a -f file.txt ]
if [ -e file.txt -a ! -d file.txt ]
```


___
### 8. Check is variable is set

Можно проверить установлена переменная или нет с помощью следующей конструкции: `[ -v var_name ]`. Полный анализ состояния переменных приведен в следующей таблице:

переменная | состояние | `[ -v var ]` | `[ -z $var ]`
-|-|-|-
`unset var`|неустановлена|false|true
`var=`|пуста|true|true
`var=abc`|непуста|true|false

>[!warning] В этом случае перед переменной знак `$` не нужен!
